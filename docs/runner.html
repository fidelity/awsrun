<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>awsrun.runner API documentation</title>
<meta name="description" content="Executes a `Command` across one or more accounts concurrently â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- <link href="/awsrun/webfonts.css" rel="stylesheet"> -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Roboto:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
body {
font-size: 16px;
font-family: 'Roboto', sans-serif;
}
code {
font-family: 'Roboto Mono', monospace;
}
#content {
max-width: 100ch;
}
/* `Text` size and code in main body text */
section code {
font-size: 14px;
}
/* Line height for blocks of code in main text */
pre code {
font-size: 13px;
line-height: 1.35em;
}
/* "expand source code" text */
details {
font-size: 12px;
}
/* Code block in the expand source section */
.source pre code {
font-size: 12px;
line-height: 1.35em;
}
/* Navbar code */
ul li code a {
font-size: 14px;
}
/* Used in method names sections etc .. */
code.name {
font-size: 14px;
}
dt {
font-weight: bold;
}
h1 {
font-size: 2.0em;
}
h4 {
font-weight: bold;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>awsrun.runner</code></h1>
</header>
<section id="section-intro">
<p>Executes a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> across one or more accounts concurrently.</p>
<h2 id="overview">Overview</h2>
<p>This module defines two core classes: <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> and <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code>.
<code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code>
is a user-defined computation to be executed concurrently across one or more
accounts by the <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code>. Typically, commands are simply a set of boto3
calls, or similar cloud SDK calls, to be run within an account using credentials
provided by a <code><a title="awsrun.session.SessionProvider" href="session/index.html#awsrun.session.SessionProvider">SessionProvider</a></code> from the <code><a title="awsrun.session" href="session/index.html">awsrun.session</a></code> module.
All commands must be subclasses of <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code>. For cloud SDKs that have
regional-based APIs , such as AWS and its boto3 library, the abstract base class
<code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code> is provided to simplify the execution of commands across
regions.</p>
<p><em>Note: When building a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> for use via the <code><a title="awsrun.cli" href="cli.html">awsrun.cli</a></code> tool, the subclass
of the command must be called <code>CLICommand</code> and must be in its own module, so the
<code><a title="awsrun.cmdmgr" href="cmdmgr.html">awsrun.cmdmgr</a></code> can find and load it.</em></p>
<h2 id="basic-usage">Basic Usage</h2>
<p>The following is a full example that demonstrates how to use the awsrun library
to programmatically execute the included <code><a title="awsrun.commands.aws.access_report" href="commands/aws/access_report.html">awsrun.commands.aws.access_report</a></code>
command for two accounts using credentials stored in local config files with the
<code><a title="awsrun.session.aws.CredsViaProfile" href="session/aws.html#awsrun.session.aws.CredsViaProfile">CredsViaProfile</a></code> session provider:</p>
<pre><code>from awsrun.runner import AccountRunner
from awsrun.session.aws import CredsViaProfile
from awsrun.commands.aws import access_report

session_provider = CredsViaProfile()
account_runner = AccountRunner(session_provider)

cmd = access_report.CLICommand()
account_runner.run(cmd, ['111222333444', '222333444111'])
</code></pre>
<p>The <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> method will block until the command has been executed
for each account. After the command has finished, the same <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code> can
be used to execute additional commands. A new instance is not required for each
command invocation.</p>
<h2 id="user-defined-commands">User-Defined Commands</h2>
<p>Users may define their own custom commands. The next example demonstrates how to
write a simple <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> that will print a list of VPCs IDs to the console for
the same accounts in two AWS regions:</p>
<pre><code>from awsrun.runner import AccountRunner, Command
from awsrun.session import CredsViaProfile

class VpcInfoCommand(Command):
    def __init__(self, regions):
        self.regions = regions

    def execute(self, session, acct):
        result = ''
        for region in self.regions:
            ec2 = session.resource('ec2', region_name=region)
            vpc_ids = ', '.join(vpc.id for vpc in ec2.vpcs.all())
            result += f'{acct}/{region}: {vpc_ids}\n'
        return result

cmd = VpcInfoCommand(['us-east-1', 'us-west-2'])
session_provider = CredsViaProfile()
account_runner = AccountRunner(session_provider)
account_runner.run(cmd, ['111222333444', '222333444111'])
</code></pre>
<p>The returned value from <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code> is printed to the console because the
default implementation of <code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code>. This may be fine for a
command intended to be run from the included <code><a title="awsrun.cli" href="cli.html">awsrun.cli</a></code> tool, but is likely
undesirable for programmatic use. The next section will present other options
for the collection of results intended for non-CLI uses.</p>
<p>Because AWS uses regional API calls, the above example can be rewritten using
<code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code> to abstract away the explicit looping over regions and the
accumulation of results, which simplifies the building of commands intended for
use with AWS. The key differences include <code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">RegionalCommand.regional_execute()</a></code>,
which takes an extra argument containing the name of the region being processed,
and the elimination of the constructor as the regional command provides a
default constructor:</p>
<pre><code>from awsrun.runner import AccountRunner, RegionalCommand
from awsrun.session import CredsViaProfile

class VpcInfoCommand(RegionalCommand):
    def regional_execute(self, session, acct, region):
        ec2 = session.resource('ec2', region_name=region)
        vpc_ids = ', '.join(vpc.id for vpc in ec2.vpcs.all())
        return f'{acct}/{region}: {vpc_ids}\n'

cmd = VpcInfoCommand(['us-east-1', 'us-west-2'])
session_provider = CredsViaProfile()
account_runner = AccountRunner(session_provider)
account_runner.run(cmd, ['111222333444', '222333444111'])
</code></pre>
<h2 id="collecting-results">Collecting Results</h2>
<p>The final example demonstrates how to collect the results from all of the
accounts and invocations of <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code>, which is common if one wants to
compute an aggregated value or access to the data after <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> has
completed processing all accounts. To do so, a custom <code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code>
must be defined. The following example accumulates the list of VPCs in the
specified regions:</p>
<pre><code>from collections import defaultdict
from awsrun.runner import AccountRunner, Command
from awsrun.session import CredsViaProfile

class VpcInfoCommand(Command):
    def __init__(self, regions):
        self.regions = regions
        self.vpcs_by_region = defaultdict(list)

    def execute(self, session, acct):
        result = {}
        for region in self.regions:
            ec2 = session.resource('ec2', region_name=region)
            result[region] = [vpc.id for vpc in ec2.vpcs.all()]
        return result

    def collect_results(self, acct, get_result):
        for region, vpc_ids in get_result().items():
            self.vpcs_by_region[region].extend(vpc_ids)

cmd = VpcInfoCommand(['us-east-1', 'us-west-2'])
session_provider = CredsViaProfile()
account_runner = AccountRunner(session_provider)
account_runner.run(cmd, ['111222333444', '222333444111'])

for region, vpc_ids in cmd.vpcs_by_region.items():
    # Do something with region and list of vpc_ids
</code></pre>
<p>This highlights an important aspect of a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code>. One must not mutate instance
variables without synchronization from within <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code>. Remember, the
<code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code> is concurrently executing the same command across multiple
accounts, so unsynchronized access may lead to data corruption or race
conditions. Instead, command authors should implement <code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code>,
which is guaranteed to be called sequentially after each account has been
processed, thus allowing users to safely mutate instance variables from within
the method.</p>
<p>The above example can also be rewritten using <code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code> like the prior
section to abstract away the explicit looping over regions and the accumulation
of results, which simplifies the implementation of this command intended for
AWS. When subclassing <code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code>, if the constructor is overridden, you
must invoke the parent's constructor passing it the list of <code>regions</code> to
process. In addition, the other difference is the region parameter on the
<code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">RegionalCommand.regional_execute()</a></code> and
<code><a title="awsrun.runner.RegionalCommand.regional_collect_results" href="#awsrun.runner.RegionalCommand.regional_collect_results">RegionalCommand.regional_collect_results()</a></code> methods:</p>
<pre><code>from collections import defaultdict
from awsrun.runner import AccountRunner, RegionalCommand
from awsrun.session import CredsViaProfile

class VpcInfoCommand(RegionalCommand):
    def __init__(self, regions):
        super().__init__(regions)
        self.vpcs_by_region = defaultdict(list)

    def regional_execute(self, session, acct, region):
        ec2 = session.resource('ec2', region_name=region)
        return [vpc.id for vpc in ec2.vpcs.all()]

    def regional_collect_results(self, acct, region, get_result):
        self.vpcs_by_region[region].extend(get_result())

cmd = VpcInfoCommand(['us-east-1', 'us-west-2'])
session_provider = CredsViaProfile()
account_runner = AccountRunner(session_provider)
account_runner.run(cmd, ['111222333444', '222333444111'])
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright 2019 FMR LLC &lt;opensource@fidelity.com&gt;
#
# SPDX-License-Identifier: MIT
#
&#34;&#34;&#34;Executes a `Command` across one or more accounts concurrently.

## Overview

This module defines two core classes: `Command` and `AccountRunner`.  `Command`
is a user-defined computation to be executed concurrently across one or more
accounts by the `AccountRunner`. Typically, commands are simply a set of boto3
calls, or similar cloud SDK calls, to be run within an account using credentials
provided by a `awsrun.session.SessionProvider` from the `awsrun.session` module.
All commands must be subclasses of `Command`. For cloud SDKs that have
regional-based APIs , such as AWS and its boto3 library, the abstract base class
`RegionalCommand` is provided to simplify the execution of commands across
regions.

*Note: When building a `Command` for use via the `awsrun.cli` tool, the subclass
of the command must be called `CLICommand` and must be in its own module, so the
`awsrun.cmdmgr` can find and load it.*

## Basic Usage

The following is a full example that demonstrates how to use the awsrun library
to programmatically execute the included `awsrun.commands.aws.access_report`
command for two accounts using credentials stored in local config files with the
`awsrun.session.aws.CredsViaProfile` session provider:

    from awsrun.runner import AccountRunner
    from awsrun.session.aws import CredsViaProfile
    from awsrun.commands.aws import access_report

    session_provider = CredsViaProfile()
    account_runner = AccountRunner(session_provider)

    cmd = access_report.CLICommand()
    account_runner.run(cmd, [&#39;111222333444&#39;, &#39;222333444111&#39;])

The `AccountRunner.run` method will block until the command has been executed
for each account. After the command has finished, the same `AccountRunner` can
be used to execute additional commands. A new instance is not required for each
command invocation.

## User-Defined Commands

Users may define their own custom commands. The next example demonstrates how to
write a simple `Command` that will print a list of VPCs IDs to the console for
the same accounts in two AWS regions:

    from awsrun.runner import AccountRunner, Command
    from awsrun.session import CredsViaProfile

    class VpcInfoCommand(Command):
        def __init__(self, regions):
            self.regions = regions

        def execute(self, session, acct):
            result = &#39;&#39;
            for region in self.regions:
                ec2 = session.resource(&#39;ec2&#39;, region_name=region)
                vpc_ids = &#39;, &#39;.join(vpc.id for vpc in ec2.vpcs.all())
                result += f&#39;{acct}/{region}: {vpc_ids}\\n&#39;
            return result

    cmd = VpcInfoCommand([&#39;us-east-1&#39;, &#39;us-west-2&#39;])
    session_provider = CredsViaProfile()
    account_runner = AccountRunner(session_provider)
    account_runner.run(cmd, [&#39;111222333444&#39;, &#39;222333444111&#39;])

The returned value from `Command.execute` is printed to the console because the
default implementation of `Command.collect_results`. This may be fine for a
command intended to be run from the included `awsrun.cli` tool, but is likely
undesirable for programmatic use. The next section will present other options
for the collection of results intended for non-CLI uses.

Because AWS uses regional API calls, the above example can be rewritten using
`RegionalCommand` to abstract away the explicit looping over regions and the
accumulation of results, which simplifies the building of commands intended for
use with AWS. The key differences include `RegionalCommand.regional_execute`,
which takes an extra argument containing the name of the region being processed,
and the elimination of the constructor as the regional command provides a
default constructor:

    from awsrun.runner import AccountRunner, RegionalCommand
    from awsrun.session import CredsViaProfile

    class VpcInfoCommand(RegionalCommand):
        def regional_execute(self, session, acct, region):
            ec2 = session.resource(&#39;ec2&#39;, region_name=region)
            vpc_ids = &#39;, &#39;.join(vpc.id for vpc in ec2.vpcs.all())
            return f&#39;{acct}/{region}: {vpc_ids}\\n&#39;

    cmd = VpcInfoCommand([&#39;us-east-1&#39;, &#39;us-west-2&#39;])
    session_provider = CredsViaProfile()
    account_runner = AccountRunner(session_provider)
    account_runner.run(cmd, [&#39;111222333444&#39;, &#39;222333444111&#39;])

## Collecting Results

The final example demonstrates how to collect the results from all of the
accounts and invocations of `Command.execute`, which is common if one wants to
compute an aggregated value or access to the data after `AccountRunner.run` has
completed processing all accounts. To do so, a custom `Command.collect_results`
must be defined. The following example accumulates the list of VPCs in the
specified regions:

    from collections import defaultdict
    from awsrun.runner import AccountRunner, Command
    from awsrun.session import CredsViaProfile

    class VpcInfoCommand(Command):
        def __init__(self, regions):
            self.regions = regions
            self.vpcs_by_region = defaultdict(list)

        def execute(self, session, acct):
            result = {}
            for region in self.regions:
                ec2 = session.resource(&#39;ec2&#39;, region_name=region)
                result[region] = [vpc.id for vpc in ec2.vpcs.all()]
            return result

        def collect_results(self, acct, get_result):
            for region, vpc_ids in get_result().items():
                self.vpcs_by_region[region].extend(vpc_ids)

    cmd = VpcInfoCommand([&#39;us-east-1&#39;, &#39;us-west-2&#39;])
    session_provider = CredsViaProfile()
    account_runner = AccountRunner(session_provider)
    account_runner.run(cmd, [&#39;111222333444&#39;, &#39;222333444111&#39;])

    for region, vpc_ids in cmd.vpcs_by_region.items():
        # Do something with region and list of vpc_ids

This highlights an important aspect of a `Command`. One must not mutate instance
variables without synchronization from within `Command.execute`. Remember, the
`AccountRunner` is concurrently executing the same command across multiple
accounts, so unsynchronized access may lead to data corruption or race
conditions. Instead, command authors should implement `Command.collect_results`,
which is guaranteed to be called sequentially after each account has been
processed, thus allowing users to safely mutate instance variables from within
the method.

The above example can also be rewritten using `RegionalCommand` like the prior
section to abstract away the explicit looping over regions and the accumulation
of results, which simplifies the implementation of this command intended for
AWS. When subclassing `RegionalCommand`, if the constructor is overridden, you
must invoke the parent&#39;s constructor passing it the list of `regions` to
process. In addition, the other difference is the region parameter on the
`RegionalCommand.regional_execute` and
`RegionalCommand.regional_collect_results` methods:

    from collections import defaultdict
    from awsrun.runner import AccountRunner, RegionalCommand
    from awsrun.session import CredsViaProfile

    class VpcInfoCommand(RegionalCommand):
        def __init__(self, regions):
            super().__init__(regions)
            self.vpcs_by_region = defaultdict(list)

        def regional_execute(self, session, acct, region):
            ec2 = session.resource(&#39;ec2&#39;, region_name=region)
            return [vpc.id for vpc in ec2.vpcs.all()]

        def regional_collect_results(self, acct, region, get_result):
            self.vpcs_by_region[region].extend(get_result())

    cmd = VpcInfoCommand([&#39;us-east-1&#39;, &#39;us-west-2&#39;])
    session_provider = CredsViaProfile()
    account_runner = AccountRunner(session_provider)
    account_runner.run(cmd, [&#39;111222333444&#39;, &#39;222333444111&#39;])
&#34;&#34;&#34;
import functools
import logging
import sys
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import Callable

from awsrun.argparse import AppendWithoutDefault
from awsrun.config import List, Str
from awsrun.session import SessionProvider

LOG = logging.getLogger(__name__)


class Command:
    &#34;&#34;&#34;Abstract base class that represents a command to execute on an account.

    A command is a unit of work that is executed across one or more accounts by
    the `AccountRunner`. During processing of an account, the command is
    provided a session configured with the appropriate credentials. In addition,
    the command is also provided an account object for the account being
    processed. The attributes and methods attached to the account object depend
    on what was passed to `AccountRunner.run`. This allows users to pass
    arbitrary account objects for use within their custom commands.

    All user-defined awsrun commands must be a subclass this base class. This
    class documents the contract between the awsrun framework and command
    author. For several examples on how to write custom commands, refer to the
    built-in commands included in the `awsrun.commands` module.
    &#34;&#34;&#34;

    @classmethod
    def from_cli(cls, parser, argv, cfg):  # pylint: disable=unused-argument
        &#34;&#34;&#34;Factory to build the command from CLI args and user configuration.

        *This method is only required if the command is intended for use with
        the `awsrun.cli` command line. Non-CLI users will not instantiate
        commands via this factory method.*

        The CLI uses `awsrun.cmdmgr` to find, load, and instantiate commands.
        This factory is called by the `awsrun.cmdmgr.CommandManager` and must
        return an instance of the command. Commands can hook into the command
        line argument processing of the main CLI. This allows command authors to
        define their own flags and arguments for the CLI. In addition, authors
        can pull values from the user configuration file via the
        `awsrun.config.Config` API.

        For reference, there are several types of awsrun CLI arguments as shown
        below:

            awsrun --account 100200300400 access_report --verbose
                   ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^ ^^^^^^^^^
                       main args            command     cmd args

        The `parser` argument, an `argparse.ArgumentParser`, can be used to
        define flags and arguments that follow the command name in the `cmd
        args` section. After defining arguments, it is the responsibility of
        this method to parse the `argv` argument, which contains a list of
        unparsed CLI arguments. It is expected that this method will terminate
        the program if incorrect arguments are passed to the command.  For
        example, to define and parse the `--verbose` flag from the example
        above:

            @classmethod
            def from_cli(cls, parser, argv, cfg):
                parser.add_argument(
                    &#39;--verbose&#39;, &#39;-v&#39;,
                    action=&#39;store_true&#39;,
                    default=False,
                    help=&#39;enable verbose output&#39;)

                args = parser.parse_args(argv)

                # use args as needed, in most cases, these will be passed to
                # constructor of the command as this example shows assuming
                # this command&#39;s constructor accepts a verbose keyword arg.
                return cls(**vars(args))

        To avoid namespace collisions with flag names used by the main CLI, an
        `argparse.ArgumentError` is raised if the same option name is added to
        the `parser`. This is done to avoid unintended consequences when the
        main CLI argument parser consumes a flag in the command because it
        shares the same name.

        The `cfg` argument is a callable that implements the
        `awsrun.config.Config.get` interface allowing one to query for
        type-checked key/value pairs defined in a user configuration file. The
        keys passed to `cfg` are relative to the `Commands` section of the
        configuration and the command name. Given the following user config and
        assuming that the name of this command is `access_report`:

            Commands:
                access_report:
                    verbose: True

        To obtain the value of the `verbose` option, the `cfg` callable can be
        used as follows:

            verbose = cfg(&#39;verbose&#39;, type=Bool, default=False)

        By combining the use of `parser` and `cfg`, a command author can define
        options in both the user configuration file as well as command line
        flags to override those values. For example, the following defines the
        CLI argument called `--verbose` that will default to the value of the
        `verbose` key in the user configuration file if it exists, otherwise it
        defaults to `False`:

            @classmethod
            def from_cli(cls, parser, argv, cfg):
                parser.add_argument(
                    &#39;--verbose&#39;, &#39;-v&#39;,
                    action=&#39;store_true&#39;,
                    default=cfg(&#39;verbose&#39;, type=Bool, default=False),
                    help=&#39;enable verbose output&#39;)

                args = parser.parse_args(argv)

                # use args as needed, in most cases, these will be passed to
                # constructor of the command as this example shows assuming
                # this command&#39;s constructor accepts a verbose keyword arg.
                return cls(**vars(args))

        This is a common pattern when defining command arguments. Arguments are
        added to the parser with defaults taken from the user configuration
        file, which allows a user to omit the flags on the command line to make
        a better user experience.
        &#34;&#34;&#34;
        # If the user does not provide their own from_cli method, we want to
        # make sure that we invoke parse_args for them as it will catch any help
        # flags passed to the command and print out the docstring of the module.
        parser.parse_args(argv)
        return cls()

    def pre_hook(self):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` before any processing starts.

        This method is invoked only once per invocation of `AccountRunner.run`.
        It is not executed before each account is processed, but rather once
        before any accounts are processed.

        The default implementation does nothing.
        &#34;&#34;&#34;

    def post_hook(self):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` after all processing has completed.

        This method is invoked only once per invocation of `AccountRunner.run`.
        It is not executed after each account is processed, but rather once
        after all accounts have been processed.

        The default implementation does nothing.
        &#34;&#34;&#34;

    def execute(self, session, acct):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` to process an account.

        This method is invoked once for each account. The `session` parameter is
        a boto3 Session object, or similar cloud SDK session-like object, with
        credentials for the account being processed. The `acct` will be the same
        object that was passed in the list of accounts to `AccountRunner.run`.

        The return value from this method can be of any type. By default, this
        value will be printed to the console if a `Command.collect_results`
        implementation is not provided. If an exception is raised during the
        execution, it will be printed to the console on standard error.

        Note the following items of importance:

        1. Command authors must implement this method. There is no default
           implementation.

        2. Recognize that this method will be invoked concurrently, so
           modification of instance variables from within this method requires
           synchronization. If accumulating results, define a custom
           `Command.collect_results` which is guaranteed to be invoked
           sequentially.

        3. Do not call `sys.exit` or the entire program will terminate. The
           proper way to exit from this method is either by returning a value or
           by raising an exception.

        4. Do not print directly to the console as output will be interspersed
           with other output from other concurrently running threads processing
           other accounts. The best practice when printing is to accumulate a
           string buffer and return the buffer at the end of the method:

                def execute(self, session, acct):
                    out = io.StringIO()

                    # Do stuff
                    print(&#39;This will be printed to the console eventually&#39;, file=out)
                    # Do more stuff

                    return out.getvalue()
        &#34;&#34;&#34;
        raise NotImplementedError

    def collect_results(self, acct, get_result):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` after processing an account.

        This method is invoked by `AccountRunner.run` after each `acct` has been
        processed by `Command.execute`. The results from execute are provided
        via `get_result`, which is a callable that will either return the value
        returned by execute or raise an exception if one was raised. The `acct`
        parameter will be the same object that was passed in the list of
        accounts to `AccountRunner.run`.

        Note: `Command.collect_results` is guaranteed to be called sequentially
        by the main thread, so it is safe to mutate instance variables attached
        to the `Command` object from within this method. This allows command
        authors to safely accumulate results of processing within instance
        variables without the need for synchronization.

        The default implementation prints the return value of `Command.execute`
        to the console on standard output. If the command&#39;s execution raises an
        exception, it prints the exception to standard error and logs the stack
        trace at WARN log level.
        &#34;&#34;&#34;
        try:
            print(get_result(), end=&#34;&#34;, flush=True)

        except Exception as e:  # pylint: disable=broad-except
            LOG.warning(&#34;%s: error: %s&#34;, acct, e, exc_info=True)
            print(f&#34;{acct}: error: {e}&#34;, flush=True, file=sys.stderr)


class RegionalCommand(Command):
    &#34;&#34;&#34;Abstract base class for commands using a regional cloud SDK.

    Cloud SDKs that are regional based, such as AWS and its boto3 library, can
    use this base class to simplify the building of commands intended to be
    executed across one or more regions. The `regions` parameter is a list of
    strings representing region names that should be processed while processing
    an account. When subclassing this class, implementers that override the
    constructor must invoke the superclass constructor with the regions to
    process. For example:

        class CLICommand(RegionalCommand):
            def __init__(self, arg1, arg2, regions):
                super().__init__(regions)
                self.arg1 = arg1
                self.arg2 = arg2

    A command is a unit of work that is executed across one or more accounts and
    regions by the `AccountRunner`. During processing of an account and region,
    the command is provided a boto3 session, or similar cloud SDK session-like
    object, configured with the appropriate credentials. In addition, the
    command is provided an account object for the account being processed. The
    attributes and methods attached to the account object depend on what was
    passed to `AccountRunner.run`. This allows users to pass arbitrary account
    objects for use within their custom commands.

    This class documents the contract between the awsrun framework and command
    author. Subclasses must implement `RegionalCommand.regional_execute`. For
    examples on how to write custom regional commands, refer to the built-in
    commands included in the `awsrun.commands` module.
    &#34;&#34;&#34;

    @classmethod
    def from_cli(cls, parser, argv, cfg):
        # If the user does not provide their own from_cli method, we make sure
        # that we invoke parse_args and add the --region flag on their behalf.
        parser.add_argument(
            &#34;--region&#34;,
            &#34;-r&#34;,
            action=AppendWithoutDefault,
            default=cfg(&#34;region&#34;, type=List(Str), default=[]),
            dest=&#34;regions&#34;,
            metavar=&#34;REGION&#34;,
            help=&#34;region in which to run commands&#34;,
        )

        # Delegate out to the user defining their command
        command = cls.regional_from_cli(parser, argv, cfg)

        # Make sure that a user&#39;s subclass of the RegionalCommand has called our
        # constructor where the &#39;regions&#39; instance variable is set to a non-zero
        # length list of regions to parse. On a side note, we do not use the
        # &#39;required&#39; keyword with ArgumentParser because we want to allow a
        # default value to be provided via the user config file. So, we check to
        # see if this is an empty list here, and if so, then complain and exit.
        if not command.regions:
            parser.error(&#34;No regions specified&#34;)

        return command

    @classmethod
    def regional_from_cli(cls, parser, argv, cfg):  # pylint: disable=unused-argument
        &#34;&#34;&#34;Factory to build a regional command from CLI args and user configuration.

        *This method is only required if the command is intended for use with
        the `awsrun.cli` command line. Non-CLI users will not instantiate
        commands via this factory method.*

        Refer to `Command.from_cli` for in-depth discussion on the use of this
        factory method. This method only adds the following additional behavior
        to simplify building a factory for a regional command:

        1. The `parser` has already added the `--region` and `-r` arguments to
           allow users to specify one or more regions to process via command
           line arguments. In addition, a default value can be provided via the
           user configuration under the &#34;region&#34; key in the specific command
           section. The values chosen by the user will be available in the
           namespace returned by the parser as `regions`. The following is used
           to register the arguments on behalf of the regional command author:

                parser.add_argument(
                    &#39;--region&#39;, &#39;-r&#39;,
                    action=AppendWithoutDefault,
                    default=cfg(&#39;region&#39;, type=List(Str), default=[]),
                    dest=&#39;regions&#39;,
                    metavar=&#39;REGION&#39;,
                    help=&#39;Region in which to run commands&#39;)

        2. The chosen regions must be passed to the command&#39;s constructor
           because subclasses of `RegionalCommand` must invoke its constructor,
           which requires a list of regions to process. If the instance returned
           from this factory method does not have a non-zero `regions` instance
           variable, a usage error is displayed to the user and the program
           terminates.

        When overriding this method, do not invoke the superclass method.
        &#34;&#34;&#34;
        args = parser.parse_args(argv)
        return cls(regions=args.regions)

    def __init__(self, regions):
        self.regions = regions

    def execute(self, session, acct):
        return [
            (r, _wrap_result(self.regional_execute, session, acct, r))
            for r in self.regions
        ]

    def regional_execute(self, session, acct, region):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` to process an account / region pair.

        This method is invoked for each account and region pair. The `session`
        parameter is a boto3 Session object, or similar cloud SDK session-like
        object, with credentials for the account being processed. The `acct`
        will be the same object that was passed in the list of accounts to
        `AccountRunner.run`. `region` is a string representing the region name
        such as &#34;us-east-1&#34;.

        The return value can be of any type. It will be, by default, printed to
        the console if a `RegionalCommand.regional_collect_results`
        implementation is not provided. If an exception is raised during the
        execution, it will be printed to the console on standard error.

        Note the following items of importance:

        1. Command authors must implement this method. There is no default
           implementation.

        2. Recognize that this method will be invoked concurrently, so
           modification of instance variables from within this method requires
           synchronization. If accumulating results, define a custom
           `RegionalCommand.regional_collect_results` which is guaranteed to be
           invoked sequentially.

        3. Although accounts are processed concurrently, the regions are
           processed sequentially for each account. This ensures that multiple
           regions for the same account are never executed at the same time. It
           provides command authors a guarantee that an account and all its
           regions will be processed sequentially. The same session object and
           credentials are provided to this method for each region being
           processed. Credentials could expire if processing of regions takes a
           significant amount of time.

        4. Do not call `sys.exit` or the entire program will terminate. The
           proper way to exit from this method is either by returning a value or
           by raising an exception.

        5. Do not print directly to the console as output will be interspersed
           with other output from other concurrently running threads processing
           other accounts. The best practice when printing is to accumulate a
           string buffer and return the buffer at the end of the method:

                def regional_execute(self, session, acct, region):
                    out = io.StringIO()

                    # Do stuff
                    print(&#39;This will be printed to the console eventually&#39;, file=out)
                    # Do more stuff

                    return out.getvalue()
        &#34;&#34;&#34;
        raise NotImplementedError

    def collect_results(self, acct, get_result):
        try:
            for region, get_region_result in get_result():
                self.regional_collect_results(acct, region, get_region_result)

        except Exception as e:  # pylint: disable=broad-except
            LOG.warning(&#34;%s: error: %s&#34;, acct, e, exc_info=True)
            print(f&#34;{acct}: error: {e}&#34;, flush=True, file=sys.stderr)

    def regional_collect_results(self, acct, region, get_result):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` after processing an account and region.

        This method is invoked by `AccountRunner.run` after each `acct` /
        `region` pair has been processed by `RegionalCommand.regional_execute`.
        The results from execute are provided via `get_result`, which is a
        callable that will either return the value returned by the regional
        execute method or raise an exception if one was raised. The `acct`
        parameter will be the same object that was passed in the list of
        accounts to `AccountRunner.run`.

        Note: `RegionalCommand.regional_collect_results` is guaranteed to be
        called sequentially by the main thread, so it is safe to mutate instance
        variables attached to the `RegionalCommand` object from within this
        method. This allows command authors to safely accumulate results of
        processing within instance variables without the need for
        synchronization.

        The default implementation prints the return value of
        `RegionalCommand.regional_execute` to the console on standard output. If
        the command&#39;s execution raises an exception, it prints the exception to
        standard error and logs the stack trace at WARN log level.
        &#34;&#34;&#34;
        try:
            print(get_result(), end=&#34;&#34;, flush=True)

        except Exception as e:  # pylint: disable=broad-except
            LOG.warning(&#34;%s/%s: error: %s&#34;, acct, region, e, exc_info=True)
            print(f&#34;{acct}/{region}: error: {e}&#34;, flush=True, file=sys.stderr)


class CommandFunctionAdapter(Command):
    &#34;&#34;&#34;Function adapter for a `Command`.

    This adapter wraps `func` in a `Command` that collects the results of the
    function and any exceptions raised in two instance variables. These are
    available for inspection after the `AccountRunner.run` has returned. The
    `func` should have the same signature as `Command.execute` sans the self
    parameter.
    &#34;&#34;&#34;

    def __init__(self, func):
        super().__init__()
        self.func = func

        self.results = {}
        &#34;&#34;&#34;Dict containing results keyed by account.&#34;&#34;&#34;

        self.errors = {}
        &#34;&#34;&#34;Dict containing exceptions keyed by account.&#34;&#34;&#34;

    def execute(self, session, acct):
        return self.func(session, acct)

    def collect_results(self, acct, get_result):
        try:
            self.results[acct] = get_result()
        except Exception as e:  # pylint: disable=broad-except
            self.errors[acct] = e


def execute_function(session_provider, accounts, func, key=lambda x: x, max_workers=10):
    &#34;&#34;&#34;Executes a function across one or more accounts concurrently.

    This is a convenience function that instantiates an `AccountRunner`, wraps a
    `func` in a `CommandFunctionAdapter`, runs the command across a list of
    `accounts`, and then returns a tuple of dicts representing the results and
    errors after all accounts have been processed. The returned dicts are keyed
    by the account.

    The list of `accounts` can be a simple list of strings of account IDs or it
    can be a list of objects that represent accounts. Passing objects can be
    useful as each object is passed to `func` when processing an account. When
    using account objects, you must provide a `key` function that returns the
    account ID as a string from the account object.

    Accounts are processed concurrently using a worker pool. The default number
    of workers is specified by the `max_workers` argument, which defaults to 10.
    &#34;&#34;&#34;
    command = CommandFunctionAdapter(func)
    AccountRunner(session_provider, max_workers=max_workers).run(
        command, accounts, key=key
    )
    return (command.results, command.errors)


class RegionalCommandFunctionAdapter(RegionalCommand):
    &#34;&#34;&#34;Function adapter for a `RegionalCommand`.

    This adapter wraps `func` in a `RegionalCommand` that collects the results
    of the function and any exceptions raised in two instance variables. These
    are available for inspection after the `AccountRunner.run` has returned. The
    `func` should have the same signature as `RegionalCommand.execute` sans the
    self parameter.
    &#34;&#34;&#34;

    def __init__(self, regions, func):
        super().__init__(regions)
        self.func = func

        self.results = {}
        &#34;&#34;&#34;Dict containing results keyed by the tuple of account and region.&#34;&#34;&#34;

        self.errors = {}
        &#34;&#34;&#34;Dict containing exceptions keyed by tuple of account and region.&#34;&#34;&#34;

    def regional_execute(self, session, acct, region):
        return self.func(session, acct, region)

    def regional_collect_results(self, acct, region, get_result):
        try:
            self.results[(acct, region)] = get_result()
        except Exception as e:  # pylint: disable=broad-except
            self.errors[(acct, region)] = e


def regional_execute_function(
    session_provider, accounts, regions, func, key=lambda x: x, max_workers=10
):
    &#34;&#34;&#34;Executes a function across one or more accounts and regions concurrently.

    This is a convenience function that instantiates an `AccountRunner`, wraps a
    `func` in a `RegionalCommandFunctionAdapter`, runs the command across a list
    of `accounts` and `regions`, and then returns a tuple of dicts representing
    the results and errors after all accounts have been processed. The returned
    dicts are keyed by a tuple of account and region.

    The list of `accounts` can be a simple list of strings of account IDs or it
    can be a list of objects that represent accounts. Passing objects can be
    useful as each object is passed to `func` when processing an account. When
    using account objects, you must provide a `key` function that returns the
    account ID as a string from the account object.

    Accounts are processed concurrently using a worker pool. The default number
    of workers is specified by the `max_workers` argument, which defaults to 10.
    &#34;&#34;&#34;
    command = RegionalCommandFunctionAdapter(regions, func)
    AccountRunner(session_provider, max_workers=max_workers).run(
        command, accounts, key=key
    )
    return (command.results, command.errors)


def max_thread_limit(count):
    &#34;&#34;&#34;Decorator to limit maximum number of concurrent executions.

    In some cases, the author of a `Command` may wish to restrict the number of
    concurrent executions of a command, regardless of the number of workers the
    `AccountRunner` has been instantiated with. awsrun CLI users can specify the
    number of workers via the `--threads` flag, which defaults to 10.

    Use this with `Command.execute` or `RegionalCommand.regional_execute` to
    guarantee concurrent executions do not exceed the specified `count`. When
    the number of concurrent executions exceed the value, they will block until
    an existing execution has completed. For example, the following will limit
    concurrent executions to one:

        @max_thread_limit(1)
        def regional_execute(self, session, acct, region):
           pass

    Note: while this decorator can limit the number of concurrent executions, it
    will not increase the number of workers in the `AccountRunner` worker pool.
    This is a rate limiting decorator only.
    &#34;&#34;&#34;

    def decorator(func):
        sem = threading.BoundedSemaphore(count)

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with sem:
                return func(*args, **kwargs)

        return wrapper

    return decorator


def get_paginated_resources(
    client,
    paginator,
    page_key,
    predicate: Callable[[dict], bool] = lambda _: True,
    **kwargs,
):
    &#34;&#34;&#34;Return the full list of boto3 resources via a paginator.

    `client` is a boto3 client.  `paginator` is the name (string) of the
    paginator.  `page_key` is the name (string) of the dictionary key used in
    the paginated responses.

    `predicate` is a function that determines which resources are included in
    the list.  The function takes a single argument, the resource. If it returns
    `True`, the resource is included, otherwise it is excluded.

    The remaining `kwargs` are used to specify which resources to retrieve. Some
    paginators do not require any additional arguments, but others do to
    restrict the size of the response.

    For example, to collect the list of load balancers, one might write:

        def get_lbs(client):
            lbs = []
            paginator = client.get_paginator(&#34;describe_load_balancers&#34;)
            for page in paginator.paginate():
                for lb in page[&#34;LoadBalancers&#34;]:
                    lbs.append(lb)
            return lbs

    This can be simplified by using `get_paginated_resources`:

        lbs = get_paginated_resources(client, &#34;describe_load_balancers&#34;, &#34;LoadBalancers&#34;)

    As another example, to collect the list of UDP listeners for a load
    balancer, one might write:

        def get_listeners(client, lb_arn):
            listeners = []
            paginator = client.get_paginator(&#34;describe_listeners&#34;)
            for page in paginator.paginate(LoadBalancerArn=lb_arn):
                for listener in page[&#34;Listeners&#34;]:
                    if listener[&#34;Protocol&#34;] in [&#34;UDP&#34;, &#34;TCP_UDP&#34;]:
                        listeners.append(listener)
            return listeners

    This, too, can be simplified using `get_paginated_resources`:

        listeners = get_paginated_resources(
            client,
            &#34;describe_listeners&#34;,
            &#34;Listeners&#34;,
            lambda l: l[&#34;Protocol&#34;] in [&#34;UDP&#34;, &#34;TCP_UDP&#34;],
            LoadBalancer=lb_arn)
    &#34;&#34;&#34;
    resources = []
    for page in client.get_paginator(paginator).paginate(**kwargs):
        for resource in page[page_key]:
            if predicate(resource):
                resources.append(resource)
    return resources


class AccountRunner:
    &#34;&#34;&#34;Runs a `Command` across one or more accounts.

    The `AccountRunner` manages the concurrent execution of a `Command` across
    one or more cloud accounts. A thread pool is used to process the accounts.
    By default, the number of workers is 10 unless the `max_workers` argument
    has been specified.

    A single worker is responsible for processing an account. The worker obtains
    a boto3 session, or similar cloud SDK session object, with the appropriate
    credentials for the account being processed by using the `session_provider`,
    which must be a subclass of `awsrun.session.SessionProvider`.

    It then invokes `Command.execute` with the session for the account being
    processed. Any exceptions raised during the invocation of a command are
    caught to prevent the termination of other threads. The result of the
    execute method, or exceptions raised, are made available to the command.
    &#34;&#34;&#34;

    def __init__(self, session_provider, max_workers=10):
        if not isinstance(session_provider, SessionProvider):
            raise TypeError(
                f&#34;&#39;{session_provider}&#39; must be a subclass of awsrun.session.SessionProvider&#34;
            )

        self.session_provider = session_provider
        self.max_workers = max_workers

    def run(self, cmd, accounts, key=lambda x: x):
        &#34;&#34;&#34;Execute a command concurrently on the specified accounts.

        This method will block until all accounts have been processed. The
        return value is the number of seconds it took to process the accounts.

        The `cmd` must be a subclass of `Command`. The runner will invoke the
        `Command.pre_hook` once before it starts processing any accounts, then
        accounts are processed concurrently and `Command.execute` is invoked by
        a worker for each account. As each execute method returns, the main
        thread will invoke `Command.collect_results`, which ensures results are
        collected sequentially. Finally, after all accounts have been processed,
        `Command.post_hook` is called.

        The specified list of `accounts` can be of any type as long as the
        function specified by the `key` parameter returns a string representing
        the cloud account ID when passed one of these accounts. This allows
        users to pass any object representing an account all the way through to
        `Command.execute`. The only contract is that a `key` function must be
        provided, so workers can obtain the account ID, which is used to request
        a session for the account.

        For example, `accounts` could be a simple list of strings of AWS account
        IDs. The default value of `key` is the identity function, which returns
        the string itself satisfying the contract above. Alternatively,
        `accounts` could be a list of dicts containing metadata for an account,
        which would then be available for command authors in `Command.execute`.
        If the list of accounts specified contained the following:

            [
                {&#39;id&#39;: &#39;100200300400&#39;, &#39;env&#39;: &#39;prod&#39;, &#39;status&#39;: &#39;active&#39;},
                {&#39;id&#39;: &#39;200300400100&#39;, &#39;env&#39;: &#39;dev&#39;, &#39;status&#39;: &#39;active&#39;},
                {&#39;id&#39;: &#39;300400100200&#39;, &#39;env&#39;: &#39;dev&#39;, &#39;status&#39;: &#39;active&#39;},
            ]

        Then, the `key` argument must be specified as `lambda x: x[&#39;id&#39;]`, which
        will return the account ID string satisfying the contract above.
        Likewise, if accounts were a list of objects that contained an `acct_id`
        attribute, `key` must be defined as `lambda x: x.acct_id` to satisfy the
        contract. If the key function does not return a string or throws an
        exception, then an `InvalidAccountIDError` is raised in the worker
        thread processing the account, which will then propagate to the
        `Command.collect_results`.
        &#34;&#34;&#34;
        # This will ensure v1 users of awsrun aren&#39;t mixing v1 Command&#39;s with
        # the v2 framework.
        if not isinstance(cmd, Command):
            raise TypeError(f&#34;&#39;{cmd}&#39; must be a subclass of awsrun.runner.Command&#34;)

        # Wrapper to ensure the user-supplied key function returns an string of
        # digits (an AWS account id). It will throw an InvalidAccountIDError
        # if there are any exceptions thrown from use of their key function.
        key = _valid_key_fn(key)

        start = time.time()
        cmd.pre_hook()

        with ThreadPoolExecutor(max_workers=self.max_workers) as pool:
            # The worker task processes a single account. The worker task takes
            # care to capture the result of the command&#39;s execute method. We
            # don&#39;t want a poorly written command that raises an exception to
            # terminate the main program, so the return value of the command&#39;s
            # execute method or any exception raised is wrapped in a callable
            # that is provided back to the command via its collect_results
            # method. When the callable is later invoked, it will return the
            # return value from execute or it will raise the caught exception.
            def worker_task(acct):
                try:
                    acct_id = key(acct)  # Get the acct id from the account obj
                    session = self.session_provider.session(acct_id)
                    return _wrap_result(cmd.execute, session, acct)

                except Exception as e:  # pylint: disable=broad-except
                    # NOTE: exceptions thrown by a Command&#39;s execute are not
                    # handled in this block, but in wrap_result above. This
                    # block handles exceptions that occur while obtaining a
                    # session for the account.
                    return _wrap_exception(e)

            # Submit all of the jobs for execution to the thread pool.
            f2a = {pool.submit(worker_task, a): a for a in accounts}

            # NOTE: collect_results is called by the main thread sequentially
            # after each worker completes their task. This is a guarantee for
            # Command authors as it allows them to safely update instance vars
            # in the Command because it is not safe to do so in the execute
            # method which is invoked in a concurrently running worker thread.
            for future in as_completed(f2a):
                acct = f2a[future]
                cmd.collect_results(acct, future.result())

        cmd.post_hook()
        return time.time() - start


class InvalidAccountIDError(Exception):
    &#34;&#34;&#34;Raised if an account ID cannot be extracted from an account object.

    This is due to an invalid key function specified to `AccountRunner.run`. The
    function either did not return a string or an exception was raised. In
    either case, a valid account ID could be be obtained from the account
    object, so this account cannot be processed.
    &#34;&#34;&#34;


def _valid_key_fn(fn):
    &#34;&#34;&#34;Wraps a function expected to return an account ID to validate the result.

    The `AccountRunner.run` method expects to receive a user-supplied key
    function that can extract the account ID from an arbitrary object that
    represents an account. The purpose of this function is to ensure the user
    has provided a valid key function. This function wraps `fn` and validates
    that it returns a string. If it does not or an error occurs, then an
    `InvalidAccountIDError` is raised when the returned function is invoked,
    otherwise the original result of `fn` is returned.
    &#34;&#34;&#34;

    def new_key_fn(*args, **kwargs):
        try:
            result = fn(*args, **kwargs)
        except Exception as e:
            raise InvalidAccountIDError(
                f&#34;The key function threw an exception: {e}&#34;
            ) from e
        if not isinstance(result, str):
            raise InvalidAccountIDError(f&#34;Account ID is not a string: {result}&#34;)
        return result

    return new_key_fn


def _wrap_result(fn, *args, **kwargs):
    &#34;&#34;&#34;Returns a function that encapsulates the result of `fn(*args, **kwargs)`.

    This function provides a means to capture the result of a computation
    regardless of whether or not the computation was successful. When the
    returned function is invoked, it will return the result of the original
    computation or re-raise any exception that was thrown. For example:

        &gt;&gt;&gt; def test(flag):
        &gt;&gt;&gt;     if flag: return 10
        &gt;&gt;&gt;     raise Exception(&#34;boom!&#34;)

        &gt;&gt;&gt; result = wrap_result(test, True)
        &gt;&gt;&gt; result()
        10

        &gt;&gt;&gt; result = wrap_result(test, False)
        &gt;&gt;&gt; result()
        Traceback (most recent call last):
          File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;
          File &#34;/awsrun/src/awsrun/runner.py&#34;, line 231, in fn
            raise exception
          File &#34;/awsrun/src/awsrun/runner.py&#34;, line 222, in _wrap_result
            result = fn(*args, **kwargs)
          File &#34;&lt;stdin&gt;&#34;, line 3, in test
        Exception: Boom!
    &#34;&#34;&#34;
    try:
        result = fn(*args, **kwargs)
        return lambda: result
    except Exception as e:  # pylint: disable=broad-except
        return _wrap_exception(e)


def _wrap_exception(exception):
    &#34;&#34;&#34;Returns a function that when invoked will raise `exception`.&#34;&#34;&#34;

    def fn():
        raise exception

    return fn</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="awsrun.runner.execute_function"><code class="name flex">
<span>def <span class="ident">execute_function</span></span>(<span>session_provider, accounts, func, key=&lt;function &lt;lambda&gt;&gt;, max_workers=10)</span>
</code></dt>
<dd>
<section class="desc"><p>Executes a function across one or more accounts concurrently.</p>
<p>This is a convenience function that instantiates an <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code>, wraps a
<code>func</code> in a <code><a title="awsrun.runner.CommandFunctionAdapter" href="#awsrun.runner.CommandFunctionAdapter">CommandFunctionAdapter</a></code>, runs the command across a list of
<code>accounts</code>, and then returns a tuple of dicts representing the results and
errors after all accounts have been processed. The returned dicts are keyed
by the account.</p>
<p>The list of <code>accounts</code> can be a simple list of strings of account IDs or it
can be a list of objects that represent accounts. Passing objects can be
useful as each object is passed to <code>func</code> when processing an account. When
using account objects, you must provide a <code>key</code> function that returns the
account ID as a string from the account object.</p>
<p>Accounts are processed concurrently using a worker pool. The default number
of workers is specified by the <code>max_workers</code> argument, which defaults to 10.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_function(session_provider, accounts, func, key=lambda x: x, max_workers=10):
    &#34;&#34;&#34;Executes a function across one or more accounts concurrently.

    This is a convenience function that instantiates an `AccountRunner`, wraps a
    `func` in a `CommandFunctionAdapter`, runs the command across a list of
    `accounts`, and then returns a tuple of dicts representing the results and
    errors after all accounts have been processed. The returned dicts are keyed
    by the account.

    The list of `accounts` can be a simple list of strings of account IDs or it
    can be a list of objects that represent accounts. Passing objects can be
    useful as each object is passed to `func` when processing an account. When
    using account objects, you must provide a `key` function that returns the
    account ID as a string from the account object.

    Accounts are processed concurrently using a worker pool. The default number
    of workers is specified by the `max_workers` argument, which defaults to 10.
    &#34;&#34;&#34;
    command = CommandFunctionAdapter(func)
    AccountRunner(session_provider, max_workers=max_workers).run(
        command, accounts, key=key
    )
    return (command.results, command.errors)</code></pre>
</details>
</dd>
<dt id="awsrun.runner.regional_execute_function"><code class="name flex">
<span>def <span class="ident">regional_execute_function</span></span>(<span>session_provider, accounts, regions, func, key=&lt;function &lt;lambda&gt;&gt;, max_workers=10)</span>
</code></dt>
<dd>
<section class="desc"><p>Executes a function across one or more accounts and regions concurrently.</p>
<p>This is a convenience function that instantiates an <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code>, wraps a
<code>func</code> in a <code><a title="awsrun.runner.RegionalCommandFunctionAdapter" href="#awsrun.runner.RegionalCommandFunctionAdapter">RegionalCommandFunctionAdapter</a></code>, runs the command across a list
of <code>accounts</code> and <code>regions</code>, and then returns a tuple of dicts representing
the results and errors after all accounts have been processed. The returned
dicts are keyed by a tuple of account and region.</p>
<p>The list of <code>accounts</code> can be a simple list of strings of account IDs or it
can be a list of objects that represent accounts. Passing objects can be
useful as each object is passed to <code>func</code> when processing an account. When
using account objects, you must provide a <code>key</code> function that returns the
account ID as a string from the account object.</p>
<p>Accounts are processed concurrently using a worker pool. The default number
of workers is specified by the <code>max_workers</code> argument, which defaults to 10.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regional_execute_function(
    session_provider, accounts, regions, func, key=lambda x: x, max_workers=10
):
    &#34;&#34;&#34;Executes a function across one or more accounts and regions concurrently.

    This is a convenience function that instantiates an `AccountRunner`, wraps a
    `func` in a `RegionalCommandFunctionAdapter`, runs the command across a list
    of `accounts` and `regions`, and then returns a tuple of dicts representing
    the results and errors after all accounts have been processed. The returned
    dicts are keyed by a tuple of account and region.

    The list of `accounts` can be a simple list of strings of account IDs or it
    can be a list of objects that represent accounts. Passing objects can be
    useful as each object is passed to `func` when processing an account. When
    using account objects, you must provide a `key` function that returns the
    account ID as a string from the account object.

    Accounts are processed concurrently using a worker pool. The default number
    of workers is specified by the `max_workers` argument, which defaults to 10.
    &#34;&#34;&#34;
    command = RegionalCommandFunctionAdapter(regions, func)
    AccountRunner(session_provider, max_workers=max_workers).run(
        command, accounts, key=key
    )
    return (command.results, command.errors)</code></pre>
</details>
</dd>
<dt id="awsrun.runner.max_thread_limit"><code class="name flex">
<span>def <span class="ident">max_thread_limit</span></span>(<span>count)</span>
</code></dt>
<dd>
<section class="desc"><p>Decorator to limit maximum number of concurrent executions.</p>
<p>In some cases, the author of a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> may wish to restrict the number of
concurrent executions of a command, regardless of the number of workers the
<code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code> has been instantiated with. awsrun CLI users can specify the
number of workers via the <code>--threads</code> flag, which defaults to 10.</p>
<p>Use this with <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code> or <code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">RegionalCommand.regional_execute()</a></code> to
guarantee concurrent executions do not exceed the specified <code>count</code>. When
the number of concurrent executions exceed the value, they will block until
an existing execution has completed. For example, the following will limit
concurrent executions to one:</p>
<pre><code>@max_thread_limit(1)
def regional_execute(self, session, acct, region):
   pass
</code></pre>
<p>Note: while this decorator can limit the number of concurrent executions, it
will not increase the number of workers in the <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code> worker pool.
This is a rate limiting decorator only.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def max_thread_limit(count):
    &#34;&#34;&#34;Decorator to limit maximum number of concurrent executions.

    In some cases, the author of a `Command` may wish to restrict the number of
    concurrent executions of a command, regardless of the number of workers the
    `AccountRunner` has been instantiated with. awsrun CLI users can specify the
    number of workers via the `--threads` flag, which defaults to 10.

    Use this with `Command.execute` or `RegionalCommand.regional_execute` to
    guarantee concurrent executions do not exceed the specified `count`. When
    the number of concurrent executions exceed the value, they will block until
    an existing execution has completed. For example, the following will limit
    concurrent executions to one:

        @max_thread_limit(1)
        def regional_execute(self, session, acct, region):
           pass

    Note: while this decorator can limit the number of concurrent executions, it
    will not increase the number of workers in the `AccountRunner` worker pool.
    This is a rate limiting decorator only.
    &#34;&#34;&#34;

    def decorator(func):
        sem = threading.BoundedSemaphore(count)

        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            with sem:
                return func(*args, **kwargs)

        return wrapper

    return decorator</code></pre>
</details>
</dd>
<dt id="awsrun.runner.get_paginated_resources"><code class="name flex">
<span>def <span class="ident">get_paginated_resources</span></span>(<span>client, paginator, page_key, predicate=&lt;function &lt;lambda&gt;&gt;, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Return the full list of boto3 resources via a paginator.</p>
<p><code>client</code> is a boto3 client.
<code>paginator</code> is the name (string) of the
paginator.
<code>page_key</code> is the name (string) of the dictionary key used in
the paginated responses.</p>
<p><code>predicate</code> is a function that determines which resources are included in
the list.
The function takes a single argument, the resource. If it returns
<code>True</code>, the resource is included, otherwise it is excluded.</p>
<p>The remaining <code>kwargs</code> are used to specify which resources to retrieve. Some
paginators do not require any additional arguments, but others do to
restrict the size of the response.</p>
<p>For example, to collect the list of load balancers, one might write:</p>
<pre><code>def get_lbs(client):
    lbs = []
    paginator = client.get_paginator("describe_load_balancers")
    for page in paginator.paginate():
        for lb in page["LoadBalancers"]:
            lbs.append(lb)
    return lbs
</code></pre>
<p>This can be simplified by using <code><a title="awsrun.runner.get_paginated_resources" href="#awsrun.runner.get_paginated_resources">get_paginated_resources()</a></code>:</p>
<pre><code>lbs = get_paginated_resources(client, "describe_load_balancers", "LoadBalancers")
</code></pre>
<p>As another example, to collect the list of UDP listeners for a load
balancer, one might write:</p>
<pre><code>def get_listeners(client, lb_arn):
    listeners = []
    paginator = client.get_paginator("describe_listeners")
    for page in paginator.paginate(LoadBalancerArn=lb_arn):
        for listener in page["Listeners"]:
            if listener["Protocol"] in ["UDP", "TCP_UDP"]:
                listeners.append(listener)
    return listeners
</code></pre>
<p>This, too, can be simplified using <code><a title="awsrun.runner.get_paginated_resources" href="#awsrun.runner.get_paginated_resources">get_paginated_resources()</a></code>:</p>
<pre><code>listeners = get_paginated_resources(
    client,
    "describe_listeners",
    "Listeners",
    lambda l: l["Protocol"] in ["UDP", "TCP_UDP"],
    LoadBalancer=lb_arn)
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_paginated_resources(
    client,
    paginator,
    page_key,
    predicate: Callable[[dict], bool] = lambda _: True,
    **kwargs,
):
    &#34;&#34;&#34;Return the full list of boto3 resources via a paginator.

    `client` is a boto3 client.  `paginator` is the name (string) of the
    paginator.  `page_key` is the name (string) of the dictionary key used in
    the paginated responses.

    `predicate` is a function that determines which resources are included in
    the list.  The function takes a single argument, the resource. If it returns
    `True`, the resource is included, otherwise it is excluded.

    The remaining `kwargs` are used to specify which resources to retrieve. Some
    paginators do not require any additional arguments, but others do to
    restrict the size of the response.

    For example, to collect the list of load balancers, one might write:

        def get_lbs(client):
            lbs = []
            paginator = client.get_paginator(&#34;describe_load_balancers&#34;)
            for page in paginator.paginate():
                for lb in page[&#34;LoadBalancers&#34;]:
                    lbs.append(lb)
            return lbs

    This can be simplified by using `get_paginated_resources`:

        lbs = get_paginated_resources(client, &#34;describe_load_balancers&#34;, &#34;LoadBalancers&#34;)

    As another example, to collect the list of UDP listeners for a load
    balancer, one might write:

        def get_listeners(client, lb_arn):
            listeners = []
            paginator = client.get_paginator(&#34;describe_listeners&#34;)
            for page in paginator.paginate(LoadBalancerArn=lb_arn):
                for listener in page[&#34;Listeners&#34;]:
                    if listener[&#34;Protocol&#34;] in [&#34;UDP&#34;, &#34;TCP_UDP&#34;]:
                        listeners.append(listener)
            return listeners

    This, too, can be simplified using `get_paginated_resources`:

        listeners = get_paginated_resources(
            client,
            &#34;describe_listeners&#34;,
            &#34;Listeners&#34;,
            lambda l: l[&#34;Protocol&#34;] in [&#34;UDP&#34;, &#34;TCP_UDP&#34;],
            LoadBalancer=lb_arn)
    &#34;&#34;&#34;
    resources = []
    for page in client.get_paginator(paginator).paginate(**kwargs):
        for resource in page[page_key]:
            if predicate(resource):
                resources.append(resource)
    return resources</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="awsrun.runner.Command"><code class="flex name class">
<span>class <span class="ident">Command</span></span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class that represents a command to execute on an account.</p>
<p>A command is a unit of work that is executed across one or more accounts by
the <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code>. During processing of an account, the command is
provided a session configured with the appropriate credentials. In addition,
the command is also provided an account object for the account being
processed. The attributes and methods attached to the account object depend
on what was passed to <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>. This allows users to pass
arbitrary account objects for use within their custom commands.</p>
<p>All user-defined awsrun commands must be a subclass this base class. This
class documents the contract between the awsrun framework and command
author. For several examples on how to write custom commands, refer to the
built-in commands included in the <code><a title="awsrun.commands" href="commands/index.html">awsrun.commands</a></code> module.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Command:
    &#34;&#34;&#34;Abstract base class that represents a command to execute on an account.

    A command is a unit of work that is executed across one or more accounts by
    the `AccountRunner`. During processing of an account, the command is
    provided a session configured with the appropriate credentials. In addition,
    the command is also provided an account object for the account being
    processed. The attributes and methods attached to the account object depend
    on what was passed to `AccountRunner.run`. This allows users to pass
    arbitrary account objects for use within their custom commands.

    All user-defined awsrun commands must be a subclass this base class. This
    class documents the contract between the awsrun framework and command
    author. For several examples on how to write custom commands, refer to the
    built-in commands included in the `awsrun.commands` module.
    &#34;&#34;&#34;

    @classmethod
    def from_cli(cls, parser, argv, cfg):  # pylint: disable=unused-argument
        &#34;&#34;&#34;Factory to build the command from CLI args and user configuration.

        *This method is only required if the command is intended for use with
        the `awsrun.cli` command line. Non-CLI users will not instantiate
        commands via this factory method.*

        The CLI uses `awsrun.cmdmgr` to find, load, and instantiate commands.
        This factory is called by the `awsrun.cmdmgr.CommandManager` and must
        return an instance of the command. Commands can hook into the command
        line argument processing of the main CLI. This allows command authors to
        define their own flags and arguments for the CLI. In addition, authors
        can pull values from the user configuration file via the
        `awsrun.config.Config` API.

        For reference, there are several types of awsrun CLI arguments as shown
        below:

            awsrun --account 100200300400 access_report --verbose
                   ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^ ^^^^^^^^^
                       main args            command     cmd args

        The `parser` argument, an `argparse.ArgumentParser`, can be used to
        define flags and arguments that follow the command name in the `cmd
        args` section. After defining arguments, it is the responsibility of
        this method to parse the `argv` argument, which contains a list of
        unparsed CLI arguments. It is expected that this method will terminate
        the program if incorrect arguments are passed to the command.  For
        example, to define and parse the `--verbose` flag from the example
        above:

            @classmethod
            def from_cli(cls, parser, argv, cfg):
                parser.add_argument(
                    &#39;--verbose&#39;, &#39;-v&#39;,
                    action=&#39;store_true&#39;,
                    default=False,
                    help=&#39;enable verbose output&#39;)

                args = parser.parse_args(argv)

                # use args as needed, in most cases, these will be passed to
                # constructor of the command as this example shows assuming
                # this command&#39;s constructor accepts a verbose keyword arg.
                return cls(**vars(args))

        To avoid namespace collisions with flag names used by the main CLI, an
        `argparse.ArgumentError` is raised if the same option name is added to
        the `parser`. This is done to avoid unintended consequences when the
        main CLI argument parser consumes a flag in the command because it
        shares the same name.

        The `cfg` argument is a callable that implements the
        `awsrun.config.Config.get` interface allowing one to query for
        type-checked key/value pairs defined in a user configuration file. The
        keys passed to `cfg` are relative to the `Commands` section of the
        configuration and the command name. Given the following user config and
        assuming that the name of this command is `access_report`:

            Commands:
                access_report:
                    verbose: True

        To obtain the value of the `verbose` option, the `cfg` callable can be
        used as follows:

            verbose = cfg(&#39;verbose&#39;, type=Bool, default=False)

        By combining the use of `parser` and `cfg`, a command author can define
        options in both the user configuration file as well as command line
        flags to override those values. For example, the following defines the
        CLI argument called `--verbose` that will default to the value of the
        `verbose` key in the user configuration file if it exists, otherwise it
        defaults to `False`:

            @classmethod
            def from_cli(cls, parser, argv, cfg):
                parser.add_argument(
                    &#39;--verbose&#39;, &#39;-v&#39;,
                    action=&#39;store_true&#39;,
                    default=cfg(&#39;verbose&#39;, type=Bool, default=False),
                    help=&#39;enable verbose output&#39;)

                args = parser.parse_args(argv)

                # use args as needed, in most cases, these will be passed to
                # constructor of the command as this example shows assuming
                # this command&#39;s constructor accepts a verbose keyword arg.
                return cls(**vars(args))

        This is a common pattern when defining command arguments. Arguments are
        added to the parser with defaults taken from the user configuration
        file, which allows a user to omit the flags on the command line to make
        a better user experience.
        &#34;&#34;&#34;
        # If the user does not provide their own from_cli method, we want to
        # make sure that we invoke parse_args for them as it will catch any help
        # flags passed to the command and print out the docstring of the module.
        parser.parse_args(argv)
        return cls()

    def pre_hook(self):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` before any processing starts.

        This method is invoked only once per invocation of `AccountRunner.run`.
        It is not executed before each account is processed, but rather once
        before any accounts are processed.

        The default implementation does nothing.
        &#34;&#34;&#34;

    def post_hook(self):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` after all processing has completed.

        This method is invoked only once per invocation of `AccountRunner.run`.
        It is not executed after each account is processed, but rather once
        after all accounts have been processed.

        The default implementation does nothing.
        &#34;&#34;&#34;

    def execute(self, session, acct):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` to process an account.

        This method is invoked once for each account. The `session` parameter is
        a boto3 Session object, or similar cloud SDK session-like object, with
        credentials for the account being processed. The `acct` will be the same
        object that was passed in the list of accounts to `AccountRunner.run`.

        The return value from this method can be of any type. By default, this
        value will be printed to the console if a `Command.collect_results`
        implementation is not provided. If an exception is raised during the
        execution, it will be printed to the console on standard error.

        Note the following items of importance:

        1. Command authors must implement this method. There is no default
           implementation.

        2. Recognize that this method will be invoked concurrently, so
           modification of instance variables from within this method requires
           synchronization. If accumulating results, define a custom
           `Command.collect_results` which is guaranteed to be invoked
           sequentially.

        3. Do not call `sys.exit` or the entire program will terminate. The
           proper way to exit from this method is either by returning a value or
           by raising an exception.

        4. Do not print directly to the console as output will be interspersed
           with other output from other concurrently running threads processing
           other accounts. The best practice when printing is to accumulate a
           string buffer and return the buffer at the end of the method:

                def execute(self, session, acct):
                    out = io.StringIO()

                    # Do stuff
                    print(&#39;This will be printed to the console eventually&#39;, file=out)
                    # Do more stuff

                    return out.getvalue()
        &#34;&#34;&#34;
        raise NotImplementedError

    def collect_results(self, acct, get_result):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` after processing an account.

        This method is invoked by `AccountRunner.run` after each `acct` has been
        processed by `Command.execute`. The results from execute are provided
        via `get_result`, which is a callable that will either return the value
        returned by execute or raise an exception if one was raised. The `acct`
        parameter will be the same object that was passed in the list of
        accounts to `AccountRunner.run`.

        Note: `Command.collect_results` is guaranteed to be called sequentially
        by the main thread, so it is safe to mutate instance variables attached
        to the `Command` object from within this method. This allows command
        authors to safely accumulate results of processing within instance
        variables without the need for synchronization.

        The default implementation prints the return value of `Command.execute`
        to the console on standard output. If the command&#39;s execution raises an
        exception, it prints the exception to standard error and logs the stack
        trace at WARN log level.
        &#34;&#34;&#34;
        try:
            print(get_result(), end=&#34;&#34;, flush=True)

        except Exception as e:  # pylint: disable=broad-except
            LOG.warning(&#34;%s: error: %s&#34;, acct, e, exc_info=True)
            print(f&#34;{acct}: error: {e}&#34;, flush=True, file=sys.stderr)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<code><li><a title="awsrun.commands.aws.access_report.CLICommand" href="commands/aws/access_report.html#awsrun.commands.aws.access_report.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.console.CLICommand" href="commands/aws/console.html#awsrun.commands.aws.console.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_iam_policies.CLICommand" href="commands/aws/list_iam_policies.html#awsrun.commands.aws.list_iam_policies.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_iam_roles.CLICommand" href="commands/aws/list_iam_roles.html#awsrun.commands.aws.list_iam_roles.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.azure.az.CLICommand" href="commands/azure/az.html#awsrun.commands.azure.az.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.azure.cidr_overlap.CLICommand" href="commands/azure/cidr_overlap.html#awsrun.commands.azure.cidr_overlap.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.azure.list_udrs.CLICommand" href="commands/azure/list_udrs.html#awsrun.commands.azure.list_udrs.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.azure.list_vnets.CLICommand" href="commands/azure/list_vnets.html#awsrun.commands.azure.list_vnets.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.runner.CommandFunctionAdapter" href="#awsrun.runner.CommandFunctionAdapter">CommandFunctionAdapter</a></li></code>
<code><li><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></li></code>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="awsrun.runner.Command.from_cli"><code class="name flex">
<span>def <span class="ident">from_cli</span></span>(<span>parser, argv, cfg)</span>
</code></dt>
<dd>
<section class="desc"><p>Factory to build the command from CLI args and user configuration.</p>
<p><em>This method is only required if the command is intended for use with
the <code><a title="awsrun.cli" href="cli.html">awsrun.cli</a></code> command line. Non-CLI users will not instantiate
commands via this factory method.</em></p>
<p>The CLI uses <code><a title="awsrun.cmdmgr" href="cmdmgr.html">awsrun.cmdmgr</a></code> to find, load, and instantiate commands.
This factory is called by the <code><a title="awsrun.cmdmgr.CommandManager" href="cmdmgr.html#awsrun.cmdmgr.CommandManager">CommandManager</a></code> and must
return an instance of the command. Commands can hook into the command
line argument processing of the main CLI. This allows command authors to
define their own flags and arguments for the CLI. In addition, authors
can pull values from the user configuration file via the
<code><a title="awsrun.config.Config" href="config.html#awsrun.config.Config">Config</a></code> API.</p>
<p>For reference, there are several types of awsrun CLI arguments as shown
below:</p>
<pre><code>awsrun --account 100200300400 access_report --verbose
       ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^ ^^^^^^^^^
           main args            command     cmd args
</code></pre>
<p>The <code>parser</code> argument, an <code>argparse.ArgumentParser</code>, can be used to
define flags and arguments that follow the command name in the <code>cmd
args</code> section. After defining arguments, it is the responsibility of
this method to parse the <code>argv</code> argument, which contains a list of
unparsed CLI arguments. It is expected that this method will terminate
the program if incorrect arguments are passed to the command.
For
example, to define and parse the <code>--verbose</code> flag from the example
above:</p>
<pre><code>@classmethod
def from_cli(cls, parser, argv, cfg):
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        default=False,
        help='enable verbose output')

    args = parser.parse_args(argv)

    # use args as needed, in most cases, these will be passed to
    # constructor of the command as this example shows assuming
    # this command's constructor accepts a verbose keyword arg.
    return cls(**vars(args))
</code></pre>
<p>To avoid namespace collisions with flag names used by the main CLI, an
<code>argparse.ArgumentError</code> is raised if the same option name is added to
the <code>parser</code>. This is done to avoid unintended consequences when the
main CLI argument parser consumes a flag in the command because it
shares the same name.</p>
<p>The <code>cfg</code> argument is a callable that implements the
<code><a title="awsrun.config.Config.get" href="config.html#awsrun.config.Config.get">Config.get()</a></code> interface allowing one to query for
type-checked key/value pairs defined in a user configuration file. The
keys passed to <code>cfg</code> are relative to the <code>Commands</code> section of the
configuration and the command name. Given the following user config and
assuming that the name of this command is <code>access_report</code>:</p>
<pre><code>Commands:
    access_report:
        verbose: True
</code></pre>
<p>To obtain the value of the <code>verbose</code> option, the <code>cfg</code> callable can be
used as follows:</p>
<pre><code>verbose = cfg('verbose', type=Bool, default=False)
</code></pre>
<p>By combining the use of <code>parser</code> and <code>cfg</code>, a command author can define
options in both the user configuration file as well as command line
flags to override those values. For example, the following defines the
CLI argument called <code>--verbose</code> that will default to the value of the
<code>verbose</code> key in the user configuration file if it exists, otherwise it
defaults to <code>False</code>:</p>
<pre><code>@classmethod
def from_cli(cls, parser, argv, cfg):
    parser.add_argument(
        '--verbose', '-v',
        action='store_true',
        default=cfg('verbose', type=Bool, default=False),
        help='enable verbose output')

    args = parser.parse_args(argv)

    # use args as needed, in most cases, these will be passed to
    # constructor of the command as this example shows assuming
    # this command's constructor accepts a verbose keyword arg.
    return cls(**vars(args))
</code></pre>
<p>This is a common pattern when defining command arguments. Arguments are
added to the parser with defaults taken from the user configuration
file, which allows a user to omit the flags on the command line to make
a better user experience.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_cli(cls, parser, argv, cfg):  # pylint: disable=unused-argument
    &#34;&#34;&#34;Factory to build the command from CLI args and user configuration.

    *This method is only required if the command is intended for use with
    the `awsrun.cli` command line. Non-CLI users will not instantiate
    commands via this factory method.*

    The CLI uses `awsrun.cmdmgr` to find, load, and instantiate commands.
    This factory is called by the `awsrun.cmdmgr.CommandManager` and must
    return an instance of the command. Commands can hook into the command
    line argument processing of the main CLI. This allows command authors to
    define their own flags and arguments for the CLI. In addition, authors
    can pull values from the user configuration file via the
    `awsrun.config.Config` API.

    For reference, there are several types of awsrun CLI arguments as shown
    below:

        awsrun --account 100200300400 access_report --verbose
               ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^ ^^^^^^^^^
                   main args            command     cmd args

    The `parser` argument, an `argparse.ArgumentParser`, can be used to
    define flags and arguments that follow the command name in the `cmd
    args` section. After defining arguments, it is the responsibility of
    this method to parse the `argv` argument, which contains a list of
    unparsed CLI arguments. It is expected that this method will terminate
    the program if incorrect arguments are passed to the command.  For
    example, to define and parse the `--verbose` flag from the example
    above:

        @classmethod
        def from_cli(cls, parser, argv, cfg):
            parser.add_argument(
                &#39;--verbose&#39;, &#39;-v&#39;,
                action=&#39;store_true&#39;,
                default=False,
                help=&#39;enable verbose output&#39;)

            args = parser.parse_args(argv)

            # use args as needed, in most cases, these will be passed to
            # constructor of the command as this example shows assuming
            # this command&#39;s constructor accepts a verbose keyword arg.
            return cls(**vars(args))

    To avoid namespace collisions with flag names used by the main CLI, an
    `argparse.ArgumentError` is raised if the same option name is added to
    the `parser`. This is done to avoid unintended consequences when the
    main CLI argument parser consumes a flag in the command because it
    shares the same name.

    The `cfg` argument is a callable that implements the
    `awsrun.config.Config.get` interface allowing one to query for
    type-checked key/value pairs defined in a user configuration file. The
    keys passed to `cfg` are relative to the `Commands` section of the
    configuration and the command name. Given the following user config and
    assuming that the name of this command is `access_report`:

        Commands:
            access_report:
                verbose: True

    To obtain the value of the `verbose` option, the `cfg` callable can be
    used as follows:

        verbose = cfg(&#39;verbose&#39;, type=Bool, default=False)

    By combining the use of `parser` and `cfg`, a command author can define
    options in both the user configuration file as well as command line
    flags to override those values. For example, the following defines the
    CLI argument called `--verbose` that will default to the value of the
    `verbose` key in the user configuration file if it exists, otherwise it
    defaults to `False`:

        @classmethod
        def from_cli(cls, parser, argv, cfg):
            parser.add_argument(
                &#39;--verbose&#39;, &#39;-v&#39;,
                action=&#39;store_true&#39;,
                default=cfg(&#39;verbose&#39;, type=Bool, default=False),
                help=&#39;enable verbose output&#39;)

            args = parser.parse_args(argv)

            # use args as needed, in most cases, these will be passed to
            # constructor of the command as this example shows assuming
            # this command&#39;s constructor accepts a verbose keyword arg.
            return cls(**vars(args))

    This is a common pattern when defining command arguments. Arguments are
    added to the parser with defaults taken from the user configuration
    file, which allows a user to omit the flags on the command line to make
    a better user experience.
    &#34;&#34;&#34;
    # If the user does not provide their own from_cli method, we want to
    # make sure that we invoke parse_args for them as it will catch any help
    # flags passed to the command and print out the docstring of the module.
    parser.parse_args(argv)
    return cls()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="awsrun.runner.Command.pre_hook"><code class="name flex">
<span>def <span class="ident">pre_hook</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> before any processing starts.</p>
<p>This method is invoked only once per invocation of <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>.
It is not executed before each account is processed, but rather once
before any accounts are processed.</p>
<p>The default implementation does nothing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pre_hook(self):
    &#34;&#34;&#34;Invoked by `AccountRunner.run` before any processing starts.

    This method is invoked only once per invocation of `AccountRunner.run`.
    It is not executed before each account is processed, but rather once
    before any accounts are processed.

    The default implementation does nothing.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="awsrun.runner.Command.post_hook"><code class="name flex">
<span>def <span class="ident">post_hook</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> after all processing has completed.</p>
<p>This method is invoked only once per invocation of <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>.
It is not executed after each account is processed, but rather once
after all accounts have been processed.</p>
<p>The default implementation does nothing.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_hook(self):
    &#34;&#34;&#34;Invoked by `AccountRunner.run` after all processing has completed.

    This method is invoked only once per invocation of `AccountRunner.run`.
    It is not executed after each account is processed, but rather once
    after all accounts have been processed.

    The default implementation does nothing.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="awsrun.runner.Command.execute"><code class="name flex">
<span>def <span class="ident">execute</span></span>(<span>self, session, acct)</span>
</code></dt>
<dd>
<section class="desc"><p>Invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> to process an account.</p>
<p>This method is invoked once for each account. The <code>session</code> parameter is
a boto3 Session object, or similar cloud SDK session-like object, with
credentials for the account being processed. The <code>acct</code> will be the same
object that was passed in the list of accounts to <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>.</p>
<p>The return value from this method can be of any type. By default, this
value will be printed to the console if a <code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code>
implementation is not provided. If an exception is raised during the
execution, it will be printed to the console on standard error.</p>
<p>Note the following items of importance:</p>
<ol>
<li>
<p>Command authors must implement this method. There is no default
implementation.</p>
</li>
<li>
<p>Recognize that this method will be invoked concurrently, so
modification of instance variables from within this method requires
synchronization. If accumulating results, define a custom
<code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code> which is guaranteed to be invoked
sequentially.</p>
</li>
<li>
<p>Do not call <code>sys.exit</code> or the entire program will terminate. The
proper way to exit from this method is either by returning a value or
by raising an exception.</p>
</li>
<li>
<p>Do not print directly to the console as output will be interspersed
with other output from other concurrently running threads processing
other accounts. The best practice when printing is to accumulate a
string buffer and return the buffer at the end of the method:</p>
<pre><code>def execute(self, session, acct):
    out = io.StringIO()

    # Do stuff
    print('This will be printed to the console eventually', file=out)
    # Do more stuff

    return out.getvalue()
</code></pre>
</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute(self, session, acct):
    &#34;&#34;&#34;Invoked by `AccountRunner.run` to process an account.

    This method is invoked once for each account. The `session` parameter is
    a boto3 Session object, or similar cloud SDK session-like object, with
    credentials for the account being processed. The `acct` will be the same
    object that was passed in the list of accounts to `AccountRunner.run`.

    The return value from this method can be of any type. By default, this
    value will be printed to the console if a `Command.collect_results`
    implementation is not provided. If an exception is raised during the
    execution, it will be printed to the console on standard error.

    Note the following items of importance:

    1. Command authors must implement this method. There is no default
       implementation.

    2. Recognize that this method will be invoked concurrently, so
       modification of instance variables from within this method requires
       synchronization. If accumulating results, define a custom
       `Command.collect_results` which is guaranteed to be invoked
       sequentially.

    3. Do not call `sys.exit` or the entire program will terminate. The
       proper way to exit from this method is either by returning a value or
       by raising an exception.

    4. Do not print directly to the console as output will be interspersed
       with other output from other concurrently running threads processing
       other accounts. The best practice when printing is to accumulate a
       string buffer and return the buffer at the end of the method:

            def execute(self, session, acct):
                out = io.StringIO()

                # Do stuff
                print(&#39;This will be printed to the console eventually&#39;, file=out)
                # Do more stuff

                return out.getvalue()
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="awsrun.runner.Command.collect_results"><code class="name flex">
<span>def <span class="ident">collect_results</span></span>(<span>self, acct, get_result)</span>
</code></dt>
<dd>
<section class="desc"><p>Invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> after processing an account.</p>
<p>This method is invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> after each <code>acct</code> has been
processed by <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code>. The results from execute are provided
via <code>get_result</code>, which is a callable that will either return the value
returned by execute or raise an exception if one was raised. The <code>acct</code>
parameter will be the same object that was passed in the list of
accounts to <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>.</p>
<p>Note: <code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code> is guaranteed to be called sequentially
by the main thread, so it is safe to mutate instance variables attached
to the <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> object from within this method. This allows command
authors to safely accumulate results of processing within instance
variables without the need for synchronization.</p>
<p>The default implementation prints the return value of <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code>
to the console on standard output. If the command's execution raises an
exception, it prints the exception to standard error and logs the stack
trace at WARN log level.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_results(self, acct, get_result):
    &#34;&#34;&#34;Invoked by `AccountRunner.run` after processing an account.

    This method is invoked by `AccountRunner.run` after each `acct` has been
    processed by `Command.execute`. The results from execute are provided
    via `get_result`, which is a callable that will either return the value
    returned by execute or raise an exception if one was raised. The `acct`
    parameter will be the same object that was passed in the list of
    accounts to `AccountRunner.run`.

    Note: `Command.collect_results` is guaranteed to be called sequentially
    by the main thread, so it is safe to mutate instance variables attached
    to the `Command` object from within this method. This allows command
    authors to safely accumulate results of processing within instance
    variables without the need for synchronization.

    The default implementation prints the return value of `Command.execute`
    to the console on standard output. If the command&#39;s execution raises an
    exception, it prints the exception to standard error and logs the stack
    trace at WARN log level.
    &#34;&#34;&#34;
    try:
        print(get_result(), end=&#34;&#34;, flush=True)

    except Exception as e:  # pylint: disable=broad-except
        LOG.warning(&#34;%s: error: %s&#34;, acct, e, exc_info=True)
        print(f&#34;{acct}: error: {e}&#34;, flush=True, file=sys.stderr)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="awsrun.runner.RegionalCommand"><code class="flex name class">
<span>class <span class="ident">RegionalCommand</span></span>
<span>(</span><span>regions)</span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for commands using a regional cloud SDK.</p>
<p>Cloud SDKs that are regional based, such as AWS and its boto3 library, can
use this base class to simplify the building of commands intended to be
executed across one or more regions. The <code>regions</code> parameter is a list of
strings representing region names that should be processed while processing
an account. When subclassing this class, implementers that override the
constructor must invoke the superclass constructor with the regions to
process. For example:</p>
<pre><code>class CLICommand(RegionalCommand):
    def __init__(self, arg1, arg2, regions):
        super().__init__(regions)
        self.arg1 = arg1
        self.arg2 = arg2
</code></pre>
<p>A command is a unit of work that is executed across one or more accounts and
regions by the <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code>. During processing of an account and region,
the command is provided a boto3 session, or similar cloud SDK session-like
object, configured with the appropriate credentials. In addition, the
command is provided an account object for the account being processed. The
attributes and methods attached to the account object depend on what was
passed to <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>. This allows users to pass arbitrary account
objects for use within their custom commands.</p>
<p>This class documents the contract between the awsrun framework and command
author. Subclasses must implement <code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">RegionalCommand.regional_execute()</a></code>. For
examples on how to write custom regional commands, refer to the built-in
commands included in the <code><a title="awsrun.commands" href="commands/index.html">awsrun.commands</a></code> module.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegionalCommand(Command):
    &#34;&#34;&#34;Abstract base class for commands using a regional cloud SDK.

    Cloud SDKs that are regional based, such as AWS and its boto3 library, can
    use this base class to simplify the building of commands intended to be
    executed across one or more regions. The `regions` parameter is a list of
    strings representing region names that should be processed while processing
    an account. When subclassing this class, implementers that override the
    constructor must invoke the superclass constructor with the regions to
    process. For example:

        class CLICommand(RegionalCommand):
            def __init__(self, arg1, arg2, regions):
                super().__init__(regions)
                self.arg1 = arg1
                self.arg2 = arg2

    A command is a unit of work that is executed across one or more accounts and
    regions by the `AccountRunner`. During processing of an account and region,
    the command is provided a boto3 session, or similar cloud SDK session-like
    object, configured with the appropriate credentials. In addition, the
    command is provided an account object for the account being processed. The
    attributes and methods attached to the account object depend on what was
    passed to `AccountRunner.run`. This allows users to pass arbitrary account
    objects for use within their custom commands.

    This class documents the contract between the awsrun framework and command
    author. Subclasses must implement `RegionalCommand.regional_execute`. For
    examples on how to write custom regional commands, refer to the built-in
    commands included in the `awsrun.commands` module.
    &#34;&#34;&#34;

    @classmethod
    def from_cli(cls, parser, argv, cfg):
        # If the user does not provide their own from_cli method, we make sure
        # that we invoke parse_args and add the --region flag on their behalf.
        parser.add_argument(
            &#34;--region&#34;,
            &#34;-r&#34;,
            action=AppendWithoutDefault,
            default=cfg(&#34;region&#34;, type=List(Str), default=[]),
            dest=&#34;regions&#34;,
            metavar=&#34;REGION&#34;,
            help=&#34;region in which to run commands&#34;,
        )

        # Delegate out to the user defining their command
        command = cls.regional_from_cli(parser, argv, cfg)

        # Make sure that a user&#39;s subclass of the RegionalCommand has called our
        # constructor where the &#39;regions&#39; instance variable is set to a non-zero
        # length list of regions to parse. On a side note, we do not use the
        # &#39;required&#39; keyword with ArgumentParser because we want to allow a
        # default value to be provided via the user config file. So, we check to
        # see if this is an empty list here, and if so, then complain and exit.
        if not command.regions:
            parser.error(&#34;No regions specified&#34;)

        return command

    @classmethod
    def regional_from_cli(cls, parser, argv, cfg):  # pylint: disable=unused-argument
        &#34;&#34;&#34;Factory to build a regional command from CLI args and user configuration.

        *This method is only required if the command is intended for use with
        the `awsrun.cli` command line. Non-CLI users will not instantiate
        commands via this factory method.*

        Refer to `Command.from_cli` for in-depth discussion on the use of this
        factory method. This method only adds the following additional behavior
        to simplify building a factory for a regional command:

        1. The `parser` has already added the `--region` and `-r` arguments to
           allow users to specify one or more regions to process via command
           line arguments. In addition, a default value can be provided via the
           user configuration under the &#34;region&#34; key in the specific command
           section. The values chosen by the user will be available in the
           namespace returned by the parser as `regions`. The following is used
           to register the arguments on behalf of the regional command author:

                parser.add_argument(
                    &#39;--region&#39;, &#39;-r&#39;,
                    action=AppendWithoutDefault,
                    default=cfg(&#39;region&#39;, type=List(Str), default=[]),
                    dest=&#39;regions&#39;,
                    metavar=&#39;REGION&#39;,
                    help=&#39;Region in which to run commands&#39;)

        2. The chosen regions must be passed to the command&#39;s constructor
           because subclasses of `RegionalCommand` must invoke its constructor,
           which requires a list of regions to process. If the instance returned
           from this factory method does not have a non-zero `regions` instance
           variable, a usage error is displayed to the user and the program
           terminates.

        When overriding this method, do not invoke the superclass method.
        &#34;&#34;&#34;
        args = parser.parse_args(argv)
        return cls(regions=args.regions)

    def __init__(self, regions):
        self.regions = regions

    def execute(self, session, acct):
        return [
            (r, _wrap_result(self.regional_execute, session, acct, r))
            for r in self.regions
        ]

    def regional_execute(self, session, acct, region):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` to process an account / region pair.

        This method is invoked for each account and region pair. The `session`
        parameter is a boto3 Session object, or similar cloud SDK session-like
        object, with credentials for the account being processed. The `acct`
        will be the same object that was passed in the list of accounts to
        `AccountRunner.run`. `region` is a string representing the region name
        such as &#34;us-east-1&#34;.

        The return value can be of any type. It will be, by default, printed to
        the console if a `RegionalCommand.regional_collect_results`
        implementation is not provided. If an exception is raised during the
        execution, it will be printed to the console on standard error.

        Note the following items of importance:

        1. Command authors must implement this method. There is no default
           implementation.

        2. Recognize that this method will be invoked concurrently, so
           modification of instance variables from within this method requires
           synchronization. If accumulating results, define a custom
           `RegionalCommand.regional_collect_results` which is guaranteed to be
           invoked sequentially.

        3. Although accounts are processed concurrently, the regions are
           processed sequentially for each account. This ensures that multiple
           regions for the same account are never executed at the same time. It
           provides command authors a guarantee that an account and all its
           regions will be processed sequentially. The same session object and
           credentials are provided to this method for each region being
           processed. Credentials could expire if processing of regions takes a
           significant amount of time.

        4. Do not call `sys.exit` or the entire program will terminate. The
           proper way to exit from this method is either by returning a value or
           by raising an exception.

        5. Do not print directly to the console as output will be interspersed
           with other output from other concurrently running threads processing
           other accounts. The best practice when printing is to accumulate a
           string buffer and return the buffer at the end of the method:

                def regional_execute(self, session, acct, region):
                    out = io.StringIO()

                    # Do stuff
                    print(&#39;This will be printed to the console eventually&#39;, file=out)
                    # Do more stuff

                    return out.getvalue()
        &#34;&#34;&#34;
        raise NotImplementedError

    def collect_results(self, acct, get_result):
        try:
            for region, get_region_result in get_result():
                self.regional_collect_results(acct, region, get_region_result)

        except Exception as e:  # pylint: disable=broad-except
            LOG.warning(&#34;%s: error: %s&#34;, acct, e, exc_info=True)
            print(f&#34;{acct}: error: {e}&#34;, flush=True, file=sys.stderr)

    def regional_collect_results(self, acct, region, get_result):
        &#34;&#34;&#34;Invoked by `AccountRunner.run` after processing an account and region.

        This method is invoked by `AccountRunner.run` after each `acct` /
        `region` pair has been processed by `RegionalCommand.regional_execute`.
        The results from execute are provided via `get_result`, which is a
        callable that will either return the value returned by the regional
        execute method or raise an exception if one was raised. The `acct`
        parameter will be the same object that was passed in the list of
        accounts to `AccountRunner.run`.

        Note: `RegionalCommand.regional_collect_results` is guaranteed to be
        called sequentially by the main thread, so it is safe to mutate instance
        variables attached to the `RegionalCommand` object from within this
        method. This allows command authors to safely accumulate results of
        processing within instance variables without the need for
        synchronization.

        The default implementation prints the return value of
        `RegionalCommand.regional_execute` to the console on standard output. If
        the command&#39;s execution raises an exception, it prints the exception to
        standard error and logs the stack trace at WARN log level.
        &#34;&#34;&#34;
        try:
            print(get_result(), end=&#34;&#34;, flush=True)

        except Exception as e:  # pylint: disable=broad-except
            LOG.warning(&#34;%s/%s: error: %s&#34;, acct, region, e, exc_info=True)
            print(f&#34;{acct}/{region}: error: {e}&#34;, flush=True, file=sys.stderr)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></li></code>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<code><li><a title="awsrun.commands.aws.aws.CLICommand" href="commands/aws/aws.html#awsrun.commands.aws.aws.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.cidr_overlap.CLICommand" href="commands/aws/cidr_overlap.html#awsrun.commands.aws.cidr_overlap.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.dx_maint.CLICommand" href="commands/aws/dx_maint.html#awsrun.commands.aws.dx_maint.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.dx_status.CLICommand" href="commands/aws/dx_status.html#awsrun.commands.aws.dx_status.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.kubectl.CLICommand" href="commands/aws/kubectl.html#awsrun.commands.aws.kubectl.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.last.CLICommand" href="commands/aws/last.html#awsrun.commands.aws.last.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_hosted_zones.CLICommand" href="commands/aws/list_hosted_zones.html#awsrun.commands.aws.list_hosted_zones.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_igws.CLICommand" href="commands/aws/list_igws.html#awsrun.commands.aws.list_igws.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_lambdas.CLICommand" href="commands/aws/list_lambdas.html#awsrun.commands.aws.list_lambdas.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_public_ips.CLICommand" href="commands/aws/list_public_ips.html#awsrun.commands.aws.list_public_ips.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_vpc_attribute.CLICommand" href="commands/aws/list_vpc_attribute.html#awsrun.commands.aws.list_vpc_attribute.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.commands.aws.list_vpcs.CLICommand" href="commands/aws/list_vpcs.html#awsrun.commands.aws.list_vpcs.CLICommand">CLICommand</a></li></code>
<code><li><a title="awsrun.runner.RegionalCommandFunctionAdapter" href="#awsrun.runner.RegionalCommandFunctionAdapter">RegionalCommandFunctionAdapter</a></li></code>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="awsrun.runner.RegionalCommand.regional_from_cli"><code class="name flex">
<span>def <span class="ident">regional_from_cli</span></span>(<span>parser, argv, cfg)</span>
</code></dt>
<dd>
<section class="desc"><p>Factory to build a regional command from CLI args and user configuration.</p>
<p><em>This method is only required if the command is intended for use with
the <code><a title="awsrun.cli" href="cli.html">awsrun.cli</a></code> command line. Non-CLI users will not instantiate
commands via this factory method.</em></p>
<p>Refer to <code><a title="awsrun.runner.Command.from_cli" href="#awsrun.runner.Command.from_cli">Command.from_cli()</a></code> for in-depth discussion on the use of this
factory method. This method only adds the following additional behavior
to simplify building a factory for a regional command:</p>
<ol>
<li>
<p>The <code>parser</code> has already added the <code>--region</code> and <code>-r</code> arguments to
allow users to specify one or more regions to process via command
line arguments. In addition, a default value can be provided via the
user configuration under the "region" key in the specific command
section. The values chosen by the user will be available in the
namespace returned by the parser as <code>regions</code>. The following is used
to register the arguments on behalf of the regional command author:</p>
<pre><code>parser.add_argument(
    '--region', '-r',
    action=AppendWithoutDefault,
    default=cfg('region', type=List(Str), default=[]),
    dest='regions',
    metavar='REGION',
    help='Region in which to run commands')
</code></pre>
</li>
<li>
<p>The chosen regions must be passed to the command's constructor
because subclasses of <code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code> must invoke its constructor,
which requires a list of regions to process. If the instance returned
from this factory method does not have a non-zero <code>regions</code> instance
variable, a usage error is displayed to the user and the program
terminates.</p>
</li>
</ol>
<p>When overriding this method, do not invoke the superclass method.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def regional_from_cli(cls, parser, argv, cfg):  # pylint: disable=unused-argument
    &#34;&#34;&#34;Factory to build a regional command from CLI args and user configuration.

    *This method is only required if the command is intended for use with
    the `awsrun.cli` command line. Non-CLI users will not instantiate
    commands via this factory method.*

    Refer to `Command.from_cli` for in-depth discussion on the use of this
    factory method. This method only adds the following additional behavior
    to simplify building a factory for a regional command:

    1. The `parser` has already added the `--region` and `-r` arguments to
       allow users to specify one or more regions to process via command
       line arguments. In addition, a default value can be provided via the
       user configuration under the &#34;region&#34; key in the specific command
       section. The values chosen by the user will be available in the
       namespace returned by the parser as `regions`. The following is used
       to register the arguments on behalf of the regional command author:

            parser.add_argument(
                &#39;--region&#39;, &#39;-r&#39;,
                action=AppendWithoutDefault,
                default=cfg(&#39;region&#39;, type=List(Str), default=[]),
                dest=&#39;regions&#39;,
                metavar=&#39;REGION&#39;,
                help=&#39;Region in which to run commands&#39;)

    2. The chosen regions must be passed to the command&#39;s constructor
       because subclasses of `RegionalCommand` must invoke its constructor,
       which requires a list of regions to process. If the instance returned
       from this factory method does not have a non-zero `regions` instance
       variable, a usage error is displayed to the user and the program
       terminates.

    When overriding this method, do not invoke the superclass method.
    &#34;&#34;&#34;
    args = parser.parse_args(argv)
    return cls(regions=args.regions)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="awsrun.runner.RegionalCommand.regional_execute"><code class="name flex">
<span>def <span class="ident">regional_execute</span></span>(<span>self, session, acct, region)</span>
</code></dt>
<dd>
<section class="desc"><p>Invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> to process an account / region pair.</p>
<p>This method is invoked for each account and region pair. The <code>session</code>
parameter is a boto3 Session object, or similar cloud SDK session-like
object, with credentials for the account being processed. The <code>acct</code>
will be the same object that was passed in the list of accounts to
<code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>. <code>region</code> is a string representing the region name
such as "us-east-1".</p>
<p>The return value can be of any type. It will be, by default, printed to
the console if a <code><a title="awsrun.runner.RegionalCommand.regional_collect_results" href="#awsrun.runner.RegionalCommand.regional_collect_results">RegionalCommand.regional_collect_results()</a></code>
implementation is not provided. If an exception is raised during the
execution, it will be printed to the console on standard error.</p>
<p>Note the following items of importance:</p>
<ol>
<li>
<p>Command authors must implement this method. There is no default
implementation.</p>
</li>
<li>
<p>Recognize that this method will be invoked concurrently, so
modification of instance variables from within this method requires
synchronization. If accumulating results, define a custom
<code><a title="awsrun.runner.RegionalCommand.regional_collect_results" href="#awsrun.runner.RegionalCommand.regional_collect_results">RegionalCommand.regional_collect_results()</a></code> which is guaranteed to be
invoked sequentially.</p>
</li>
<li>
<p>Although accounts are processed concurrently, the regions are
processed sequentially for each account. This ensures that multiple
regions for the same account are never executed at the same time. It
provides command authors a guarantee that an account and all its
regions will be processed sequentially. The same session object and
credentials are provided to this method for each region being
processed. Credentials could expire if processing of regions takes a
significant amount of time.</p>
</li>
<li>
<p>Do not call <code>sys.exit</code> or the entire program will terminate. The
proper way to exit from this method is either by returning a value or
by raising an exception.</p>
</li>
<li>
<p>Do not print directly to the console as output will be interspersed
with other output from other concurrently running threads processing
other accounts. The best practice when printing is to accumulate a
string buffer and return the buffer at the end of the method:</p>
<pre><code>def regional_execute(self, session, acct, region):
    out = io.StringIO()

    # Do stuff
    print('This will be printed to the console eventually', file=out)
    # Do more stuff

    return out.getvalue()
</code></pre>
</li>
</ol></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regional_execute(self, session, acct, region):
    &#34;&#34;&#34;Invoked by `AccountRunner.run` to process an account / region pair.

    This method is invoked for each account and region pair. The `session`
    parameter is a boto3 Session object, or similar cloud SDK session-like
    object, with credentials for the account being processed. The `acct`
    will be the same object that was passed in the list of accounts to
    `AccountRunner.run`. `region` is a string representing the region name
    such as &#34;us-east-1&#34;.

    The return value can be of any type. It will be, by default, printed to
    the console if a `RegionalCommand.regional_collect_results`
    implementation is not provided. If an exception is raised during the
    execution, it will be printed to the console on standard error.

    Note the following items of importance:

    1. Command authors must implement this method. There is no default
       implementation.

    2. Recognize that this method will be invoked concurrently, so
       modification of instance variables from within this method requires
       synchronization. If accumulating results, define a custom
       `RegionalCommand.regional_collect_results` which is guaranteed to be
       invoked sequentially.

    3. Although accounts are processed concurrently, the regions are
       processed sequentially for each account. This ensures that multiple
       regions for the same account are never executed at the same time. It
       provides command authors a guarantee that an account and all its
       regions will be processed sequentially. The same session object and
       credentials are provided to this method for each region being
       processed. Credentials could expire if processing of regions takes a
       significant amount of time.

    4. Do not call `sys.exit` or the entire program will terminate. The
       proper way to exit from this method is either by returning a value or
       by raising an exception.

    5. Do not print directly to the console as output will be interspersed
       with other output from other concurrently running threads processing
       other accounts. The best practice when printing is to accumulate a
       string buffer and return the buffer at the end of the method:

            def regional_execute(self, session, acct, region):
                out = io.StringIO()

                # Do stuff
                print(&#39;This will be printed to the console eventually&#39;, file=out)
                # Do more stuff

                return out.getvalue()
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="awsrun.runner.RegionalCommand.regional_collect_results"><code class="name flex">
<span>def <span class="ident">regional_collect_results</span></span>(<span>self, acct, region, get_result)</span>
</code></dt>
<dd>
<section class="desc"><p>Invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> after processing an account and region.</p>
<p>This method is invoked by <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> after each <code>acct</code> /
<code>region</code> pair has been processed by <code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">RegionalCommand.regional_execute()</a></code>.
The results from execute are provided via <code>get_result</code>, which is a
callable that will either return the value returned by the regional
execute method or raise an exception if one was raised. The <code>acct</code>
parameter will be the same object that was passed in the list of
accounts to <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>.</p>
<p>Note: <code><a title="awsrun.runner.RegionalCommand.regional_collect_results" href="#awsrun.runner.RegionalCommand.regional_collect_results">RegionalCommand.regional_collect_results()</a></code> is guaranteed to be
called sequentially by the main thread, so it is safe to mutate instance
variables attached to the <code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code> object from within this
method. This allows command authors to safely accumulate results of
processing within instance variables without the need for
synchronization.</p>
<p>The default implementation prints the return value of
<code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">RegionalCommand.regional_execute()</a></code> to the console on standard output. If
the command's execution raises an exception, it prints the exception to
standard error and logs the stack trace at WARN log level.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regional_collect_results(self, acct, region, get_result):
    &#34;&#34;&#34;Invoked by `AccountRunner.run` after processing an account and region.

    This method is invoked by `AccountRunner.run` after each `acct` /
    `region` pair has been processed by `RegionalCommand.regional_execute`.
    The results from execute are provided via `get_result`, which is a
    callable that will either return the value returned by the regional
    execute method or raise an exception if one was raised. The `acct`
    parameter will be the same object that was passed in the list of
    accounts to `AccountRunner.run`.

    Note: `RegionalCommand.regional_collect_results` is guaranteed to be
    called sequentially by the main thread, so it is safe to mutate instance
    variables attached to the `RegionalCommand` object from within this
    method. This allows command authors to safely accumulate results of
    processing within instance variables without the need for
    synchronization.

    The default implementation prints the return value of
    `RegionalCommand.regional_execute` to the console on standard output. If
    the command&#39;s execution raises an exception, it prints the exception to
    standard error and logs the stack trace at WARN log level.
    &#34;&#34;&#34;
    try:
        print(get_result(), end=&#34;&#34;, flush=True)

    except Exception as e:  # pylint: disable=broad-except
        LOG.warning(&#34;%s/%s: error: %s&#34;, acct, region, e, exc_info=True)
        print(f&#34;{acct}/{region}: error: {e}&#34;, flush=True, file=sys.stderr)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></b></code>:
<ul class="hlist">
<li><code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">collect_results</a></code></li>
<li><code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">execute</a></code></li>
<li><code><a title="awsrun.runner.Command.from_cli" href="#awsrun.runner.Command.from_cli">from_cli</a></code></li>
<li><code><a title="awsrun.runner.Command.post_hook" href="#awsrun.runner.Command.post_hook">post_hook</a></code></li>
<li><code><a title="awsrun.runner.Command.pre_hook" href="#awsrun.runner.Command.pre_hook">pre_hook</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="awsrun.runner.CommandFunctionAdapter"><code class="flex name class">
<span>class <span class="ident">CommandFunctionAdapter</span></span>
<span>(</span><span>func)</span>
</code></dt>
<dd>
<section class="desc"><p>Function adapter for a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code>.</p>
<p>This adapter wraps <code>func</code> in a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> that collects the results of the
function and any exceptions raised in two instance variables. These are
available for inspection after the <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> has returned. The
<code>func</code> should have the same signature as <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code> sans the self
parameter.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CommandFunctionAdapter(Command):
    &#34;&#34;&#34;Function adapter for a `Command`.

    This adapter wraps `func` in a `Command` that collects the results of the
    function and any exceptions raised in two instance variables. These are
    available for inspection after the `AccountRunner.run` has returned. The
    `func` should have the same signature as `Command.execute` sans the self
    parameter.
    &#34;&#34;&#34;

    def __init__(self, func):
        super().__init__()
        self.func = func

        self.results = {}
        &#34;&#34;&#34;Dict containing results keyed by account.&#34;&#34;&#34;

        self.errors = {}
        &#34;&#34;&#34;Dict containing exceptions keyed by account.&#34;&#34;&#34;

    def execute(self, session, acct):
        return self.func(session, acct)

    def collect_results(self, acct, get_result):
        try:
            self.results[acct] = get_result()
        except Exception as e:  # pylint: disable=broad-except
            self.errors[acct] = e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></li></code>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="awsrun.runner.CommandFunctionAdapter.results"><code class="name">var <span class="ident">results</span></code></dt>
<dd>
<section class="desc"><p>Dict containing results keyed by account.</p></section>
</dd>
<dt id="awsrun.runner.CommandFunctionAdapter.errors"><code class="name">var <span class="ident">errors</span></code></dt>
<dd>
<section class="desc"><p>Dict containing exceptions keyed by account.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></b></code>:
<ul class="hlist">
<li><code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">collect_results</a></code></li>
<li><code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">execute</a></code></li>
<li><code><a title="awsrun.runner.Command.from_cli" href="#awsrun.runner.Command.from_cli">from_cli</a></code></li>
<li><code><a title="awsrun.runner.Command.post_hook" href="#awsrun.runner.Command.post_hook">post_hook</a></code></li>
<li><code><a title="awsrun.runner.Command.pre_hook" href="#awsrun.runner.Command.pre_hook">pre_hook</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="awsrun.runner.RegionalCommandFunctionAdapter"><code class="flex name class">
<span>class <span class="ident">RegionalCommandFunctionAdapter</span></span>
<span>(</span><span>regions, func)</span>
</code></dt>
<dd>
<section class="desc"><p>Function adapter for a <code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code>.</p>
<p>This adapter wraps <code>func</code> in a <code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code> that collects the results
of the function and any exceptions raised in two instance variables. These
are available for inspection after the <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code> has returned. The
<code>func</code> should have the same signature as <code><a title="awsrun.runner.RegionalCommand.execute" href="#awsrun.runner.Command.execute">RegionalCommand.execute()</a></code> sans the
self parameter.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RegionalCommandFunctionAdapter(RegionalCommand):
    &#34;&#34;&#34;Function adapter for a `RegionalCommand`.

    This adapter wraps `func` in a `RegionalCommand` that collects the results
    of the function and any exceptions raised in two instance variables. These
    are available for inspection after the `AccountRunner.run` has returned. The
    `func` should have the same signature as `RegionalCommand.execute` sans the
    self parameter.
    &#34;&#34;&#34;

    def __init__(self, regions, func):
        super().__init__(regions)
        self.func = func

        self.results = {}
        &#34;&#34;&#34;Dict containing results keyed by the tuple of account and region.&#34;&#34;&#34;

        self.errors = {}
        &#34;&#34;&#34;Dict containing exceptions keyed by tuple of account and region.&#34;&#34;&#34;

    def regional_execute(self, session, acct, region):
        return self.func(session, acct, region)

    def regional_collect_results(self, acct, region, get_result):
        try:
            self.results[(acct, region)] = get_result()
        except Exception as e:  # pylint: disable=broad-except
            self.errors[(acct, region)] = e</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></li></code>
<code><li><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></li></code>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="awsrun.runner.RegionalCommandFunctionAdapter.results"><code class="name">var <span class="ident">results</span></code></dt>
<dd>
<section class="desc"><p>Dict containing results keyed by the tuple of account and region.</p></section>
</dd>
<dt id="awsrun.runner.RegionalCommandFunctionAdapter.errors"><code class="name">var <span class="ident">errors</span></code></dt>
<dd>
<section class="desc"><p>Dict containing exceptions keyed by tuple of account and region.</p></section>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></b></code>:
<ul class="hlist">
<li><code><a title="awsrun.runner.RegionalCommand.collect_results" href="#awsrun.runner.Command.collect_results">collect_results</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.execute" href="#awsrun.runner.Command.execute">execute</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.from_cli" href="#awsrun.runner.Command.from_cli">from_cli</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.post_hook" href="#awsrun.runner.Command.post_hook">post_hook</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.pre_hook" href="#awsrun.runner.Command.pre_hook">pre_hook</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.regional_collect_results" href="#awsrun.runner.RegionalCommand.regional_collect_results">regional_collect_results</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">regional_execute</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.regional_from_cli" href="#awsrun.runner.RegionalCommand.regional_from_cli">regional_from_cli</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="awsrun.runner.AccountRunner"><code class="flex name class">
<span>class <span class="ident">AccountRunner</span></span>
<span>(</span><span>session_provider, max_workers=10)</span>
</code></dt>
<dd>
<section class="desc"><p>Runs a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> across one or more accounts.</p>
<p>The <code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code> manages the concurrent execution of a <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code> across
one or more cloud accounts. A thread pool is used to process the accounts.
By default, the number of workers is 10 unless the <code>max_workers</code> argument
has been specified.</p>
<p>A single worker is responsible for processing an account. The worker obtains
a boto3 session, or similar cloud SDK session object, with the appropriate
credentials for the account being processed by using the <code>session_provider</code>,
which must be a subclass of <code><a title="awsrun.session.SessionProvider" href="session/index.html#awsrun.session.SessionProvider">SessionProvider</a></code>.</p>
<p>It then invokes <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code> with the session for the account being
processed. Any exceptions raised during the invocation of a command are
caught to prevent the termination of other threads. The result of the
execute method, or exceptions raised, are made available to the command.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AccountRunner:
    &#34;&#34;&#34;Runs a `Command` across one or more accounts.

    The `AccountRunner` manages the concurrent execution of a `Command` across
    one or more cloud accounts. A thread pool is used to process the accounts.
    By default, the number of workers is 10 unless the `max_workers` argument
    has been specified.

    A single worker is responsible for processing an account. The worker obtains
    a boto3 session, or similar cloud SDK session object, with the appropriate
    credentials for the account being processed by using the `session_provider`,
    which must be a subclass of `awsrun.session.SessionProvider`.

    It then invokes `Command.execute` with the session for the account being
    processed. Any exceptions raised during the invocation of a command are
    caught to prevent the termination of other threads. The result of the
    execute method, or exceptions raised, are made available to the command.
    &#34;&#34;&#34;

    def __init__(self, session_provider, max_workers=10):
        if not isinstance(session_provider, SessionProvider):
            raise TypeError(
                f&#34;&#39;{session_provider}&#39; must be a subclass of awsrun.session.SessionProvider&#34;
            )

        self.session_provider = session_provider
        self.max_workers = max_workers

    def run(self, cmd, accounts, key=lambda x: x):
        &#34;&#34;&#34;Execute a command concurrently on the specified accounts.

        This method will block until all accounts have been processed. The
        return value is the number of seconds it took to process the accounts.

        The `cmd` must be a subclass of `Command`. The runner will invoke the
        `Command.pre_hook` once before it starts processing any accounts, then
        accounts are processed concurrently and `Command.execute` is invoked by
        a worker for each account. As each execute method returns, the main
        thread will invoke `Command.collect_results`, which ensures results are
        collected sequentially. Finally, after all accounts have been processed,
        `Command.post_hook` is called.

        The specified list of `accounts` can be of any type as long as the
        function specified by the `key` parameter returns a string representing
        the cloud account ID when passed one of these accounts. This allows
        users to pass any object representing an account all the way through to
        `Command.execute`. The only contract is that a `key` function must be
        provided, so workers can obtain the account ID, which is used to request
        a session for the account.

        For example, `accounts` could be a simple list of strings of AWS account
        IDs. The default value of `key` is the identity function, which returns
        the string itself satisfying the contract above. Alternatively,
        `accounts` could be a list of dicts containing metadata for an account,
        which would then be available for command authors in `Command.execute`.
        If the list of accounts specified contained the following:

            [
                {&#39;id&#39;: &#39;100200300400&#39;, &#39;env&#39;: &#39;prod&#39;, &#39;status&#39;: &#39;active&#39;},
                {&#39;id&#39;: &#39;200300400100&#39;, &#39;env&#39;: &#39;dev&#39;, &#39;status&#39;: &#39;active&#39;},
                {&#39;id&#39;: &#39;300400100200&#39;, &#39;env&#39;: &#39;dev&#39;, &#39;status&#39;: &#39;active&#39;},
            ]

        Then, the `key` argument must be specified as `lambda x: x[&#39;id&#39;]`, which
        will return the account ID string satisfying the contract above.
        Likewise, if accounts were a list of objects that contained an `acct_id`
        attribute, `key` must be defined as `lambda x: x.acct_id` to satisfy the
        contract. If the key function does not return a string or throws an
        exception, then an `InvalidAccountIDError` is raised in the worker
        thread processing the account, which will then propagate to the
        `Command.collect_results`.
        &#34;&#34;&#34;
        # This will ensure v1 users of awsrun aren&#39;t mixing v1 Command&#39;s with
        # the v2 framework.
        if not isinstance(cmd, Command):
            raise TypeError(f&#34;&#39;{cmd}&#39; must be a subclass of awsrun.runner.Command&#34;)

        # Wrapper to ensure the user-supplied key function returns an string of
        # digits (an AWS account id). It will throw an InvalidAccountIDError
        # if there are any exceptions thrown from use of their key function.
        key = _valid_key_fn(key)

        start = time.time()
        cmd.pre_hook()

        with ThreadPoolExecutor(max_workers=self.max_workers) as pool:
            # The worker task processes a single account. The worker task takes
            # care to capture the result of the command&#39;s execute method. We
            # don&#39;t want a poorly written command that raises an exception to
            # terminate the main program, so the return value of the command&#39;s
            # execute method or any exception raised is wrapped in a callable
            # that is provided back to the command via its collect_results
            # method. When the callable is later invoked, it will return the
            # return value from execute or it will raise the caught exception.
            def worker_task(acct):
                try:
                    acct_id = key(acct)  # Get the acct id from the account obj
                    session = self.session_provider.session(acct_id)
                    return _wrap_result(cmd.execute, session, acct)

                except Exception as e:  # pylint: disable=broad-except
                    # NOTE: exceptions thrown by a Command&#39;s execute are not
                    # handled in this block, but in wrap_result above. This
                    # block handles exceptions that occur while obtaining a
                    # session for the account.
                    return _wrap_exception(e)

            # Submit all of the jobs for execution to the thread pool.
            f2a = {pool.submit(worker_task, a): a for a in accounts}

            # NOTE: collect_results is called by the main thread sequentially
            # after each worker completes their task. This is a guarantee for
            # Command authors as it allows them to safely update instance vars
            # in the Command because it is not safe to do so in the execute
            # method which is invoked in a concurrently running worker thread.
            for future in as_completed(f2a):
                acct = f2a[future]
                cmd.collect_results(acct, future.result())

        cmd.post_hook()
        return time.time() - start</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="awsrun.runner.AccountRunner.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self, cmd, accounts, key=&lt;function AccountRunner.&lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<section class="desc"><p>Execute a command concurrently on the specified accounts.</p>
<p>This method will block until all accounts have been processed. The
return value is the number of seconds it took to process the accounts.</p>
<p>The <code>cmd</code> must be a subclass of <code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code>. The runner will invoke the
<code><a title="awsrun.runner.Command.pre_hook" href="#awsrun.runner.Command.pre_hook">Command.pre_hook()</a></code> once before it starts processing any accounts, then
accounts are processed concurrently and <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code> is invoked by
a worker for each account. As each execute method returns, the main
thread will invoke <code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code>, which ensures results are
collected sequentially. Finally, after all accounts have been processed,
<code><a title="awsrun.runner.Command.post_hook" href="#awsrun.runner.Command.post_hook">Command.post_hook()</a></code> is called.</p>
<p>The specified list of <code>accounts</code> can be of any type as long as the
function specified by the <code>key</code> parameter returns a string representing
the cloud account ID when passed one of these accounts. This allows
users to pass any object representing an account all the way through to
<code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code>. The only contract is that a <code>key</code> function must be
provided, so workers can obtain the account ID, which is used to request
a session for the account.</p>
<p>For example, <code>accounts</code> could be a simple list of strings of AWS account
IDs. The default value of <code>key</code> is the identity function, which returns
the string itself satisfying the contract above. Alternatively,
<code>accounts</code> could be a list of dicts containing metadata for an account,
which would then be available for command authors in <code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">Command.execute()</a></code>.
If the list of accounts specified contained the following:</p>
<pre><code>[
    {'id': '100200300400', 'env': 'prod', 'status': 'active'},
    {'id': '200300400100', 'env': 'dev', 'status': 'active'},
    {'id': '300400100200', 'env': 'dev', 'status': 'active'},
]
</code></pre>
<p>Then, the <code>key</code> argument must be specified as <code>lambda x: x['id']</code>, which
will return the account ID string satisfying the contract above.
Likewise, if accounts were a list of objects that contained an <code>acct_id</code>
attribute, <code>key</code> must be defined as <code>lambda x: x.acct_id</code> to satisfy the
contract. If the key function does not return a string or throws an
exception, then an <code><a title="awsrun.runner.InvalidAccountIDError" href="#awsrun.runner.InvalidAccountIDError">InvalidAccountIDError</a></code> is raised in the worker
thread processing the account, which will then propagate to the
<code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">Command.collect_results()</a></code>.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self, cmd, accounts, key=lambda x: x):
    &#34;&#34;&#34;Execute a command concurrently on the specified accounts.

    This method will block until all accounts have been processed. The
    return value is the number of seconds it took to process the accounts.

    The `cmd` must be a subclass of `Command`. The runner will invoke the
    `Command.pre_hook` once before it starts processing any accounts, then
    accounts are processed concurrently and `Command.execute` is invoked by
    a worker for each account. As each execute method returns, the main
    thread will invoke `Command.collect_results`, which ensures results are
    collected sequentially. Finally, after all accounts have been processed,
    `Command.post_hook` is called.

    The specified list of `accounts` can be of any type as long as the
    function specified by the `key` parameter returns a string representing
    the cloud account ID when passed one of these accounts. This allows
    users to pass any object representing an account all the way through to
    `Command.execute`. The only contract is that a `key` function must be
    provided, so workers can obtain the account ID, which is used to request
    a session for the account.

    For example, `accounts` could be a simple list of strings of AWS account
    IDs. The default value of `key` is the identity function, which returns
    the string itself satisfying the contract above. Alternatively,
    `accounts` could be a list of dicts containing metadata for an account,
    which would then be available for command authors in `Command.execute`.
    If the list of accounts specified contained the following:

        [
            {&#39;id&#39;: &#39;100200300400&#39;, &#39;env&#39;: &#39;prod&#39;, &#39;status&#39;: &#39;active&#39;},
            {&#39;id&#39;: &#39;200300400100&#39;, &#39;env&#39;: &#39;dev&#39;, &#39;status&#39;: &#39;active&#39;},
            {&#39;id&#39;: &#39;300400100200&#39;, &#39;env&#39;: &#39;dev&#39;, &#39;status&#39;: &#39;active&#39;},
        ]

    Then, the `key` argument must be specified as `lambda x: x[&#39;id&#39;]`, which
    will return the account ID string satisfying the contract above.
    Likewise, if accounts were a list of objects that contained an `acct_id`
    attribute, `key` must be defined as `lambda x: x.acct_id` to satisfy the
    contract. If the key function does not return a string or throws an
    exception, then an `InvalidAccountIDError` is raised in the worker
    thread processing the account, which will then propagate to the
    `Command.collect_results`.
    &#34;&#34;&#34;
    # This will ensure v1 users of awsrun aren&#39;t mixing v1 Command&#39;s with
    # the v2 framework.
    if not isinstance(cmd, Command):
        raise TypeError(f&#34;&#39;{cmd}&#39; must be a subclass of awsrun.runner.Command&#34;)

    # Wrapper to ensure the user-supplied key function returns an string of
    # digits (an AWS account id). It will throw an InvalidAccountIDError
    # if there are any exceptions thrown from use of their key function.
    key = _valid_key_fn(key)

    start = time.time()
    cmd.pre_hook()

    with ThreadPoolExecutor(max_workers=self.max_workers) as pool:
        # The worker task processes a single account. The worker task takes
        # care to capture the result of the command&#39;s execute method. We
        # don&#39;t want a poorly written command that raises an exception to
        # terminate the main program, so the return value of the command&#39;s
        # execute method or any exception raised is wrapped in a callable
        # that is provided back to the command via its collect_results
        # method. When the callable is later invoked, it will return the
        # return value from execute or it will raise the caught exception.
        def worker_task(acct):
            try:
                acct_id = key(acct)  # Get the acct id from the account obj
                session = self.session_provider.session(acct_id)
                return _wrap_result(cmd.execute, session, acct)

            except Exception as e:  # pylint: disable=broad-except
                # NOTE: exceptions thrown by a Command&#39;s execute are not
                # handled in this block, but in wrap_result above. This
                # block handles exceptions that occur while obtaining a
                # session for the account.
                return _wrap_exception(e)

        # Submit all of the jobs for execution to the thread pool.
        f2a = {pool.submit(worker_task, a): a for a in accounts}

        # NOTE: collect_results is called by the main thread sequentially
        # after each worker completes their task. This is a guarantee for
        # Command authors as it allows them to safely update instance vars
        # in the Command because it is not safe to do so in the execute
        # method which is invoked in a concurrently running worker thread.
        for future in as_completed(f2a):
            acct = f2a[future]
            cmd.collect_results(acct, future.result())

    cmd.post_hook()
    return time.time() - start</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="awsrun.runner.InvalidAccountIDError"><code class="flex name class">
<span>class <span class="ident">InvalidAccountIDError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Raised if an account ID cannot be extracted from an account object.</p>
<p>This is due to an invalid key function specified to <code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">AccountRunner.run()</a></code>. The
function either did not return a string or an exception was raised. In
either case, a valid account ID could be be obtained from the account
object, so this account cannot be processed.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InvalidAccountIDError(Exception):
    &#34;&#34;&#34;Raised if an account ID cannot be extracted from an account object.

    This is due to an invalid key function specified to `AccountRunner.run`. The
    function either did not return a string or an exception was raised. In
    either case, a valid account ID could be be obtained from the account
    object, so this account cannot be processed.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li>builtins.Exception</li></code>
<code><li>builtins.BaseException</li></code>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#basic-usage">Basic Usage</a></li>
<li><a href="#user-defined-commands">User-Defined Commands</a></li>
<li><a href="#collecting-results">Collecting Results</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="awsrun" href="index.html">awsrun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="awsrun.runner.execute_function" href="#awsrun.runner.execute_function">execute_function</a></code></li>
<li><code><a title="awsrun.runner.regional_execute_function" href="#awsrun.runner.regional_execute_function">regional_execute_function</a></code></li>
<li><code><a title="awsrun.runner.max_thread_limit" href="#awsrun.runner.max_thread_limit">max_thread_limit</a></code></li>
<li><code><a title="awsrun.runner.get_paginated_resources" href="#awsrun.runner.get_paginated_resources">get_paginated_resources</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="awsrun.runner.Command" href="#awsrun.runner.Command">Command</a></code></h4>
<ul class="">
<li><code><a title="awsrun.runner.Command.from_cli" href="#awsrun.runner.Command.from_cli">from_cli</a></code></li>
<li><code><a title="awsrun.runner.Command.pre_hook" href="#awsrun.runner.Command.pre_hook">pre_hook</a></code></li>
<li><code><a title="awsrun.runner.Command.post_hook" href="#awsrun.runner.Command.post_hook">post_hook</a></code></li>
<li><code><a title="awsrun.runner.Command.execute" href="#awsrun.runner.Command.execute">execute</a></code></li>
<li><code><a title="awsrun.runner.Command.collect_results" href="#awsrun.runner.Command.collect_results">collect_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="awsrun.runner.RegionalCommand" href="#awsrun.runner.RegionalCommand">RegionalCommand</a></code></h4>
<ul class="">
<li><code><a title="awsrun.runner.RegionalCommand.regional_from_cli" href="#awsrun.runner.RegionalCommand.regional_from_cli">regional_from_cli</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.regional_execute" href="#awsrun.runner.RegionalCommand.regional_execute">regional_execute</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommand.regional_collect_results" href="#awsrun.runner.RegionalCommand.regional_collect_results">regional_collect_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="awsrun.runner.CommandFunctionAdapter" href="#awsrun.runner.CommandFunctionAdapter">CommandFunctionAdapter</a></code></h4>
<ul class="">
<li><code><a title="awsrun.runner.CommandFunctionAdapter.results" href="#awsrun.runner.CommandFunctionAdapter.results">results</a></code></li>
<li><code><a title="awsrun.runner.CommandFunctionAdapter.errors" href="#awsrun.runner.CommandFunctionAdapter.errors">errors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="awsrun.runner.RegionalCommandFunctionAdapter" href="#awsrun.runner.RegionalCommandFunctionAdapter">RegionalCommandFunctionAdapter</a></code></h4>
<ul class="">
<li><code><a title="awsrun.runner.RegionalCommandFunctionAdapter.results" href="#awsrun.runner.RegionalCommandFunctionAdapter.results">results</a></code></li>
<li><code><a title="awsrun.runner.RegionalCommandFunctionAdapter.errors" href="#awsrun.runner.RegionalCommandFunctionAdapter.errors">errors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="awsrun.runner.AccountRunner" href="#awsrun.runner.AccountRunner">AccountRunner</a></code></h4>
<ul class="">
<li><code><a title="awsrun.runner.AccountRunner.run" href="#awsrun.runner.AccountRunner.run">run</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="awsrun.runner.InvalidAccountIDError" href="#awsrun.runner.InvalidAccountIDError">InvalidAccountIDError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>