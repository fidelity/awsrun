<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>awsrun.plugmgr API documentation</title>
<meta name="description" content="Loads and instantiates awsrun plug-ins for the CLI â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- <link href="/awsrun/webfonts.css" rel="stylesheet"> -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Roboto:ital,wght@0,300;0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
body {
font-size: 16px;
font-family: 'Roboto', sans-serif;
}
code {
font-family: 'Roboto Mono', monospace;
}
#content {
max-width: 100ch;
}
/* `Text` size and code in main body text */
section code {
font-size: 14px;
}
/* Line height for blocks of code in main text */
pre code {
font-size: 13px;
line-height: 1.35em;
}
/* "expand source code" text */
details {
font-size: 12px;
}
/* Code block in the expand source section */
.source pre code {
font-size: 12px;
line-height: 1.35em;
}
/* Navbar code */
ul li code a {
font-size: 14px;
}
/* Used in method names sections etc .. */
code.name {
font-size: 14px;
}
.title code {
font-family: 'Roboto', sans-serif;
}
dt {
font-weight: bold;
}
h1 {
font-size: 2.0em;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>awsrun.plugmgr</code></h1>
</header>
<section id="section-intro">
<p>Loads and instantiates awsrun plug-ins for the CLI.</p>
<h2 id="overview">Overview</h2>
<p>The awsrun CLI supports two pluggable behaviors: <strong>account loading</strong> and
<strong>credential loading</strong>. To provide choices and extensibility for CLI users,
these behaviors can be changed via a user's awsrun YAML configuration file.
There are several plug-ins included for each. Users may, alternatively, provide
their own implementations, so long as they are installed and available in the
standard Python path. Non-CLI users of awsrun will not use this module.</p>
<p>This module provides a <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> which is responsible for loading and
instantiating a <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code> as well as managing the state associated with CLI
argument processing as plug-ins can register their own CLI flags. Users specify
plug-ins and the options to those plugins in their awsrun configuration file.
Most options can also be overridden via CLI flags if desired. The documentation
for each plug-in provides details on options available in the configuration file
as well as CLI flags. Please refer to <code><a title="awsrun.plugins" href="plugins/index.html">awsrun.plugins</a></code> for details on the
pluggable behaviors and included plug-ins.</p>
<p>For example, one pluggable behavior is the <code><a title="awsrun.acctload.AccountLoader" href="acctload.html#awsrun.acctload.AccountLoader">AccountLoader</a></code>. By
default, awsrun will use the <code><a title="awsrun.plugins.accts.Identity" href="plugins/accts/index.html#awsrun.plugins.accts.Identity">Identity</a></code> plug-in unless a
user specifies an alternate plug-in in their awsrun configuration. To replace
the standard account loader, the user would define a plug-in specification block
in their config called <code>Accounts</code>. This specification block contains a <code>plugin</code>
key that is a dotted Python path to a <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code> implementation and an <code>options</code>
block containing the appropriate options for the factory method:</p>
<pre><code>Accounts:
  plugin: awsrun.plugins.accts.JSON
  options:
    url: "http://www.example.com/accounts"
    max_age: 86400
</code></pre>
<p>To load the above plug-in, create an instance of a <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code>, invoke
<code><a title="awsrun.plugmgr.PluginManager.parse_args" href="#awsrun.plugmgr.PluginManager.parse_args">PluginManager.parse_args()</a></code> to register CLI flags and defaults, and then call
<code><a title="awsrun.plugmgr.PluginManager.instantiate" href="#awsrun.plugmgr.PluginManager.instantiate">PluginManager.instantiate()</a></code> to build the instance of the plug-in. The following
illustrates how the manager interoperates with argument processing of the CLI:</p>
<pre><code># Main CLI arg parser (definition of args omitted)
parser = argparse.ArgumentParser()
args, unparsed_argv = parser.parse_known_args()

# Load and parse args for any plug-ins
pm = PluginManager(config, parser, parsed_args, unparsed_argv)
pm.parse_args('Accounts', default='awsrun.plugins.accts.Identity')

# After parsing args for all the plug-ins, parse any remaining that
# were not consumed by the plug-ins.
args = parser.parse_args(pm.remaining_argv, pm.args)

# Sometime later, instantiate your plug-in
acct_loader = pm.instantiate('Accounts', must_be=AccountLoader)
</code></pre>
<p>The parsing of arguments and the instantiation of a <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code> are two separate
steps by design. This is particularly useful when one wants to complete all of
the CLI argument processing before doing the heavy lifting of instantiating the
plug-in. Why bother instantiating one plug-in if a user has not specified the
correct args to another? This is the reason why the steps are distinct. One can,
on the other hand, combine both into a single step by omitting the call to
<code><a title="awsrun.plugmgr.PluginManager.parse_args" href="#awsrun.plugmgr.PluginManager.parse_args">PluginManager.parse_args()</a></code> as it will be called by <code><a title="awsrun.plugmgr.PluginManager.instantiate" href="#awsrun.plugmgr.PluginManager.instantiate">PluginManager.instantiate()</a></code>
if it was not already.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright 2019 FMR LLC &lt;opensource@fidelity.com&gt;
#
# SPDX-License-Identifier: MIT
#
&#34;&#34;&#34;Loads and instantiates awsrun plug-ins for the CLI.

## Overview

The awsrun CLI supports two pluggable behaviors: **account loading** and
**credential loading**. To provide choices and extensibility for CLI users,
these behaviors can be changed via a user&#39;s awsrun YAML configuration file.
There are several plug-ins included for each. Users may, alternatively, provide
their own implementations, so long as they are installed and available in the
standard Python path. Non-CLI users of awsrun will not use this module.

This module provides a `PluginManager` which is responsible for loading and
instantiating a `Plugin` as well as managing the state associated with CLI
argument processing as plug-ins can register their own CLI flags. Users specify
plug-ins and the options to those plugins in their awsrun configuration file.
Most options can also be overridden via CLI flags if desired. The documentation
for each plug-in provides details on options available in the configuration file
as well as CLI flags. Please refer to `awsrun.plugins` for details on the
pluggable behaviors and included plug-ins.

For example, one pluggable behavior is the `awsrun.acctload.AccountLoader`. By
default, awsrun will use the `awsrun.plugins.accts.Identity` plug-in unless a
user specifies an alternate plug-in in their awsrun configuration. To replace
the standard account loader, the user would define a plug-in specification block
in their config called `Accounts`. This specification block contains a `plugin`
key that is a dotted Python path to a `Plugin` implementation and an `options`
block containing the appropriate options for the factory method:

    Accounts:
      plugin: awsrun.plugins.accts.JSON
      options:
        url: &#34;http://www.example.com/accounts&#34;
        max_age: 86400

To load the above plug-in, create an instance of a `PluginManager`, invoke
`PluginManager.parse_args` to register CLI flags and defaults, and then call
`PluginManager.instantiate` to build the instance of the plug-in. The following
illustrates how the manager interoperates with argument processing of the CLI:

    # Main CLI arg parser (definition of args omitted)
    parser = argparse.ArgumentParser()
    args, unparsed_argv = parser.parse_known_args()

    # Load and parse args for any plug-ins
    pm = PluginManager(config, parser, parsed_args, unparsed_argv)
    pm.parse_args(&#39;Accounts&#39;, default=&#39;awsrun.plugins.accts.Identity&#39;)

    # After parsing args for all the plug-ins, parse any remaining that
    # were not consumed by the plug-ins.
    args = parser.parse_args(pm.remaining_argv, pm.args)

    # Sometime later, instantiate your plug-in
    acct_loader = pm.instantiate(&#39;Accounts&#39;, must_be=AccountLoader)

The parsing of arguments and the instantiation of a `Plugin` are two separate
steps by design. This is particularly useful when one wants to complete all of
the CLI argument processing before doing the heavy lifting of instantiating the
plug-in. Why bother instantiating one plug-in if a user has not specified the
correct args to another? This is the reason why the steps are distinct. One can,
on the other hand, combine both into a single step by omitting the call to
`PluginManager.parse_args` as it will be called by `PluginManager.instantiate`
if it was not already.
&#34;&#34;&#34;
import importlib
import logging
from contextlib import suppress
from functools import partial, reduce
from inspect import isclass

LOG = logging.getLogger(__name__)


class Plugin:
    &#34;&#34;&#34;Abstract base class for a plug-in that can register flags on the main CLI.

    A plug-in is a wrapper around a Python object that is configured via options
    in a user configuration file or CLI flags. This is abstract base class must
    be subclassed by plug-ins authors as the `PluginManager` will type check
    loaded plug-ins.

    Plug-ins can hook into the command line argument processing of the main CLI,
    which is done via the constructor. This allows plug-in author&#39;s to define
    options in user configuration files via `awsrun.config.Config` as well as
    flags on the command line using `argparse` library. The loading and
    instantiation of plug-ins is handled by the `PluginManager`, which is
    responsible for managing the state of CLI argument processing.

    The `parser` argument is an `argparse.ArgumentParser` that can be used to
    define additional flags on the main awsrun CLI. It is suggested that plug-in
    CLI flags are added to their own argument group, which is used by `argparse`
    when displaying help to the user:

        group = parser.add_argument_group(&#39;account loader options&#39;)
        group.add_argument(&#39;--loader-url&#39;, metavar=&#39;URL&#39;, help=&#39;URL to account data&#39;)

    If new CLI arguments are defined on the `parser`, it is highly recommended
    that they are prefixed with a name that will not conflict with the main
    awsrun CLI args. For example, a plug-in should not define a `--url` option
    as that may conflict with a future awsrun argument or another plug-in trying
    to define the same. Instead, use a prefix on all of the plug-in options
    defined to avoid conflicts. E.g., `--loader-url`.

    The `cfg` argument is a callable that implements the
    `awsrun.config.Config.get` interface allowing one to query for type-checked
    key/value pairs defined in a user configuration file. The keys passed to
    `cfg` are relative to the `options` key in the plug-in definition. For
    example, assume the following plug-in specification in a user configuration:

        Accounts:
          plugin: awsrun.plugins.accts.JSON
          options:
            url: &#34;http://www.example.com/accounts&#34;
            max_age: 86400

    To obtain the value of the `url` option, the `cfg` callable can be used:

        url = cfg(&#39;url&#39;, type=URL, must_exist=True)

    By combining the use of `parser` and `cfg`, a plug-in author can define
    options in both the user configuration file as well as command line flags to
    override those values. For example, the following defines a CLI argument
    called `--loader-max-age` that will default to the value of the `max_age`
    key in the user configuration file if it exists, otherwise it defaults to 0:

        parser.add_argument(
            &#39;--loader-max-age&#39;,
            metavar=&#39;SECS&#39;,
            type=int,
            default=cfg(&#39;max_age&#39;, type=Int, default=0),
            help=&#39;maximum age of the cache&#39;)

    **Note:** A plug-in author must not invoke the `parse_args` or
    `parse_known_args` on the `parser` object provided in the constructor. The
    `PluginManager` is responsible for managing this and maintaining the state
    associated with argument processing. The constructor should be used to only
    register new CLI arguments and invoke the superclass&#39;s constructor.
    &#34;&#34;&#34;

    def __init__(self, parser, cfg):
        self.parser = parser
        self.cfg = cfg

    def instantiate(self, args):
        &#34;&#34;&#34;Returns an object created with options and arguments defined by the plug-in.

        The `PluginManager` will invoke this method after it has completed
        parsing the command line arguments that the plug-in defined in the
        constructor. The `args` argument is a populated `argparse.Namespace`
        object that contains the values of any command line arguments provided
        by the user on the CLI.

        This method also has access to the `self.parser` and `self.cfg` objects
        that were provided in the constructor. The `self.cfg` object is useful
        for cases where one does not want to provide a CLI flag for an option
        defined in the configuration file. In this case, when instantiating the
        object, you can pull values for the configuration file.

        The `self.parser` object is useful if one wishes to abort the
        instantiation of the plug-in. `argparse.ArgumentParser.error()` can be
        used to provide an error message to the CLI user and terminate the
        program.  It is perfectly acceptable to terminate the main program from
        within this method. Alternatively, one can raise an exception which will
        also terminate the program.
        &#34;&#34;&#34;
        raise NotImplementedError


class PluginManager:
    &#34;&#34;&#34;Manages the loading and instantiation of awsrun plug-ins.

    The `PluginManager` is responsible for loading and instantiating a `Plugin`
    as well as managing the state associated with CLI argument processing as
    plug-ins can register their own CLI flags. Users specify plug-ins and the
    options to those plugins in their awsrun configuration file. Most options
    can also be overridden via CLI flags if desired. See the `awsrun.plugmgr`
    for example usage.

    The `config` argument is a `awsrun.config.Config` that contains one or more
    plug-in specifications (discussed below). `parser` is a the main CLI
    `argparse.ArgumentParser` that will be provided to plug-ins so they can
    define new CLI arguments. `parsed_args` is a `argparse.Namespace` containing
    the results of CLI argument processing up to this point. And,
    `unparsed_argv` is a list of unprocessed arguments passed on the command
    line, which might contain arguments destined for a plug-in.

    A plug-in specification identifies the name of the plug-in, the `Plugin`
    implementation, and its options. The format of the specification is as
    follows:

        PLUGIN_NAME:
          plugin: PYTHON_MODULE.CLASSNAME
          options:
            ARG1: VAL1
            ARG2: VAL2

    For example, the following is a sample plug-in specification for the
    &#34;Accounts&#34; plug-in:

        Accounts:
          plugin: awsrun.plugins.accts.JSON
          options:
            url: &#34;http://www.example.com/accounts&#34;
            max_age: 86400

    The specification must include the `plugin` key that identifies, via a
    dotted string, the Python module concatenated with the name of a `Plugin`
    subclass. Plug-ins must be installed in the standard Python path. In the
    above example, `awsrun.plugins.accts.JSON` points to a subclass called
    `JSON` in the `awsrun.plugins.accts` module. The specification can also
    optionally include the `options` key that defines options made available
    to the plug-in via an `awsrun.config.Config` object, which is passed to the
    constructor of a `Plugin`. This allows the plug-in to type check values and
    use other features of the config module.

    Plug-in authors should refer to the documentation for `Plugin` to understand
    how the `config` and `parser` interact with each other during the
    instantiation of a plug-in.
    &#34;&#34;&#34;

    def __init__(self, config, parser, parsed_args, unparsed_argv):
        self._config = config
        self._parser = parser
        self._plugins = {}

        self.args = parsed_args
        &#34;&#34;&#34;A `argparse.Namespace` that parsed plug-in arguments are added.

        After each call to `PluginManager.parse_args`, this namespace is updated
        with any unparsed arguments consumed by a `Plugin`. In addition, when
        the `PluginManager` instantiates a plug-in, this namespace is provided
        to the plug-in, so it has access to its parsed arguments.
        &#34;&#34;&#34;

        self.remaining_argv = unparsed_argv
        &#34;&#34;&#34;A list of unparsed command line arguments remaining to be parsed.

        At the start of the `PluginManager`, this contains any command line
        arguments that might be intended for one or more plug-ins. It is updated
        after each successive call to `PluginManager.parse_args`. If a plug-in
        consumes arguments, they are transferred from this unparsed list to the
        parsed `PluginManager.args` namespace.
        &#34;&#34;&#34;

    def parse_args(self, *keys, default=None):
        &#34;&#34;&#34;Load the plug-in and parse command line arguments passed via the CLI.

        This method does not return anything, nor does it instantiate the
        plug-in. It only loads the plug-in class and performs command line
        argument processing for the `Plugin`. It is provided to allow one to
        separate the parsing of all line arguments from the instantiation of
        plug-ins. If this method is not explicitly called by the user, then it
        will be implicitly called when `PluginManager.instantiate` is called.
        See the `awsrun.plugmgr` documentation for the rationale.

        The `keys` varargs specifies the path to the plug-in specification
        contained with the configuration. See the `PluginManager` documentation
        for details on the plug-in specification. If the path does not exist,
        then the value of `default` is used instead. This default value must be
        a dotted string pointing to a subclass of `Plugin`. For example:

            pm = PluginManager(config, parser, parsed_args, unparsed_argv)
            pm.parse_args(&#39;Accounts&#39;, default=&#39;awsrun.plugins.accts.Identity&#39;)

        If the `Accounts` key does not exist in the configuration, then the
        `awsrun.plugins.accts.Identity` plug-in will be used instead.
        &#34;&#34;&#34;
        path = self._config.get(*keys, &#34;plugin&#34;) or default
        LOG.info(&#34;loading plug-in: %s&#34;, path)

        try:
            plugin_class = load_dotted_object(path)

        except ImportError as e:
            raise ValueError(f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: {e}&#34;) from e

        if not (isclass(plugin_class) and issubclass(plugin_class, Plugin)):
            raise TypeError(
                f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: &#39;{path}&#39; is not a {Plugin}&#34;
            )

        # Create a new config callable that points directly to the options
        # stored in the configuration. This will make it easy for plugin authors
        # to query the config without having to specify the key path leading up
        # to the options section of the config.
        cfg = partial(self._config.get, *keys, &#34;options&#34;)

        plugin = plugin_class(self._parser, cfg)
        self.args, self.remaining_argv = self._parser.parse_known_args(
            self.remaining_argv, self.args
        )
        LOG.info(&#34;parsed args=%s remaining args=%s&#34;, self.args, self.remaining_argv)

        self._plugins[keys] = plugin

    def instantiate(self, *keys, default=None, must_be=None):
        &#34;&#34;&#34;Returns the instantiated plug-in.

        This method ultimately returns the value from `Plugin.instantiate`,
        which is passed a reference to the `PluginManager.args` object, so the
        plug-in can use any parsed command line arguments it had requested. It
        is usual, but not necessary, to invoke `PluginManager.parse_args` for
        each plug-in before calling this method. This allows all command line
        processing, and more important errors, to be complete before the actual
        instantiation of any plug-ins.

        The `keys` varargs specifies the path to the plug-in specification
        contained with the configuration. See the `PluginManager` documentation
        for details on the plug-in specification. If the path does not exist,
        then the value of `default` is used instead. This default value must be
        a dotted string pointing to a subclass of `Plugin`. For example:

            pm = PluginManager(config, parser, parsed_args, unparsed_argv)
            acct_loader = pm.instantiate(
                &#39;Accounts&#39;,
                must_be=AccountLoader,
                default=&#39;awsrun.plugins.accts.Identity&#39;)

        If the `Accounts` key does not exist in the configuration, then the
        `awsrun.plugins.accts.Identity` plug-in will be used instead. If
        `must_be` is provided, the returned value from `Plugin.instantiate` must
        be an instance of the type specified, otherwise a `TypeError` is raised.
        If `must_be` is not provided, the returned object can be of any type.
        &#34;&#34;&#34;
        if keys not in self._plugins:
            self.parse_args(*keys, default)

        instance = self._plugins[keys].instantiate(self.args)

        if must_be and not isinstance(instance, must_be):
            raise TypeError(
                f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: plugin did not build a {must_be}&#34;
            )

        return instance


def load_dotted_object(dotted_name):
    &#34;&#34;&#34;Returns the Python object found at the `dotted_name`.

    `dotted_name` should include both the Python module as well as the object in
    the module to return. For example, `some.module.MyClass` will return the
    class object `MyClass` from the Python module `some.module`. If the object
    cannot be loaded, `ImportError` is raised.
    &#34;&#34;&#34;

    def doit(mod_name, attributes=None):
        attributes = [] if attributes is None else attributes

        if not mod_name:
            raise ImportError(f&#34;cannot import &#39;{dotted_name}&#39;&#34;)

        mod = None
        with suppress(ModuleNotFoundError):
            mod = importlib.import_module(mod_name)

        if not mod:
            mod_name, _, attr = mod_name.rpartition(&#34;.&#34;)
            attributes.append(attr)
            return doit(mod_name, attributes)

        attributes.reverse()
        obj = reduce(lambda a, p: getattr(a, p, {}), attributes, mod)
        if not obj:
            raise ImportError(
                f&#34;module &#39;{mod_name}&#39; does not contain &#39;{&#39;.&#39;.join(attributes)}&#39;&#34;
            )

        return obj

    return doit(dotted_name)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="awsrun.plugmgr.load_dotted_object"><code class="name flex">
<span>def <span class="ident">load_dotted_object</span></span>(<span>dotted_name)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the Python object found at the <code>dotted_name</code>.</p>
<p><code>dotted_name</code> should include both the Python module as well as the object in
the module to return. For example, <code>some.module.MyClass</code> will return the
class object <code>MyClass</code> from the Python module <code>some.module</code>. If the object
cannot be loaded, <code>ImportError</code> is raised.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dotted_object(dotted_name):
    &#34;&#34;&#34;Returns the Python object found at the `dotted_name`.

    `dotted_name` should include both the Python module as well as the object in
    the module to return. For example, `some.module.MyClass` will return the
    class object `MyClass` from the Python module `some.module`. If the object
    cannot be loaded, `ImportError` is raised.
    &#34;&#34;&#34;

    def doit(mod_name, attributes=None):
        attributes = [] if attributes is None else attributes

        if not mod_name:
            raise ImportError(f&#34;cannot import &#39;{dotted_name}&#39;&#34;)

        mod = None
        with suppress(ModuleNotFoundError):
            mod = importlib.import_module(mod_name)

        if not mod:
            mod_name, _, attr = mod_name.rpartition(&#34;.&#34;)
            attributes.append(attr)
            return doit(mod_name, attributes)

        attributes.reverse()
        obj = reduce(lambda a, p: getattr(a, p, {}), attributes, mod)
        if not obj:
            raise ImportError(
                f&#34;module &#39;{mod_name}&#39; does not contain &#39;{&#39;.&#39;.join(attributes)}&#39;&#34;
            )

        return obj

    return doit(dotted_name)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="awsrun.plugmgr.Plugin"><code class="flex name class">
<span>class <span class="ident">Plugin</span></span>
<span>(</span><span>parser, cfg)</span>
</code></dt>
<dd>
<section class="desc"><p>Abstract base class for a plug-in that can register flags on the main CLI.</p>
<p>A plug-in is a wrapper around a Python object that is configured via options
in a user configuration file or CLI flags. This is abstract base class must
be subclassed by plug-ins authors as the <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> will type check
loaded plug-ins.</p>
<p>Plug-ins can hook into the command line argument processing of the main CLI,
which is done via the constructor. This allows plug-in author's to define
options in user configuration files via <code><a title="awsrun.config.Config" href="config.html#awsrun.config.Config">Config</a></code> as well as
flags on the command line using <code>argparse</code> library. The loading and
instantiation of plug-ins is handled by the <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code>, which is
responsible for managing the state of CLI argument processing.</p>
<p>The <code>parser</code> argument is an <code>argparse.ArgumentParser</code> that can be used to
define additional flags on the main awsrun CLI. It is suggested that plug-in
CLI flags are added to their own argument group, which is used by <code>argparse</code>
when displaying help to the user:</p>
<pre><code>group = parser.add_argument_group('account loader options')
group.add_argument('--loader-url', metavar='URL', help='URL to account data')
</code></pre>
<p>If new CLI arguments are defined on the <code>parser</code>, it is highly recommended
that they are prefixed with a name that will not conflict with the main
awsrun CLI args. For example, a plug-in should not define a <code>--url</code> option
as that may conflict with a future awsrun argument or another plug-in trying
to define the same. Instead, use a prefix on all of the plug-in options
defined to avoid conflicts. E.g., <code>--loader-url</code>.</p>
<p>The <code>cfg</code> argument is a callable that implements the
<code><a title="awsrun.config.Config.get" href="config.html#awsrun.config.Config.get">Config.get()</a></code> interface allowing one to query for type-checked
key/value pairs defined in a user configuration file. The keys passed to
<code>cfg</code> are relative to the <code>options</code> key in the plug-in definition. For
example, assume the following plug-in specification in a user configuration:</p>
<pre><code>Accounts:
  plugin: awsrun.plugins.accts.JSON
  options:
    url: "http://www.example.com/accounts"
    max_age: 86400
</code></pre>
<p>To obtain the value of the <code>url</code> option, the <code>cfg</code> callable can be used:</p>
<pre><code>url = cfg('url', type=URL, must_exist=True)
</code></pre>
<p>By combining the use of <code>parser</code> and <code>cfg</code>, a plug-in author can define
options in both the user configuration file as well as command line flags to
override those values. For example, the following defines a CLI argument
called <code>--loader-max-age</code> that will default to the value of the <code>max_age</code>
key in the user configuration file if it exists, otherwise it defaults to 0:</p>
<pre><code>parser.add_argument(
    '--loader-max-age',
    metavar='SECS',
    type=int,
    default=cfg('max_age', type=Int, default=0),
    help='maximum age of the cache')
</code></pre>
<p><strong>Note:</strong> A plug-in author must not invoke the <code>parse_args</code> or
<code>parse_known_args</code> on the <code>parser</code> object provided in the constructor. The
<code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> is responsible for managing this and maintaining the state
associated with argument processing. The constructor should be used to only
register new CLI arguments and invoke the superclass's constructor.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plugin:
    &#34;&#34;&#34;Abstract base class for a plug-in that can register flags on the main CLI.

    A plug-in is a wrapper around a Python object that is configured via options
    in a user configuration file or CLI flags. This is abstract base class must
    be subclassed by plug-ins authors as the `PluginManager` will type check
    loaded plug-ins.

    Plug-ins can hook into the command line argument processing of the main CLI,
    which is done via the constructor. This allows plug-in author&#39;s to define
    options in user configuration files via `awsrun.config.Config` as well as
    flags on the command line using `argparse` library. The loading and
    instantiation of plug-ins is handled by the `PluginManager`, which is
    responsible for managing the state of CLI argument processing.

    The `parser` argument is an `argparse.ArgumentParser` that can be used to
    define additional flags on the main awsrun CLI. It is suggested that plug-in
    CLI flags are added to their own argument group, which is used by `argparse`
    when displaying help to the user:

        group = parser.add_argument_group(&#39;account loader options&#39;)
        group.add_argument(&#39;--loader-url&#39;, metavar=&#39;URL&#39;, help=&#39;URL to account data&#39;)

    If new CLI arguments are defined on the `parser`, it is highly recommended
    that they are prefixed with a name that will not conflict with the main
    awsrun CLI args. For example, a plug-in should not define a `--url` option
    as that may conflict with a future awsrun argument or another plug-in trying
    to define the same. Instead, use a prefix on all of the plug-in options
    defined to avoid conflicts. E.g., `--loader-url`.

    The `cfg` argument is a callable that implements the
    `awsrun.config.Config.get` interface allowing one to query for type-checked
    key/value pairs defined in a user configuration file. The keys passed to
    `cfg` are relative to the `options` key in the plug-in definition. For
    example, assume the following plug-in specification in a user configuration:

        Accounts:
          plugin: awsrun.plugins.accts.JSON
          options:
            url: &#34;http://www.example.com/accounts&#34;
            max_age: 86400

    To obtain the value of the `url` option, the `cfg` callable can be used:

        url = cfg(&#39;url&#39;, type=URL, must_exist=True)

    By combining the use of `parser` and `cfg`, a plug-in author can define
    options in both the user configuration file as well as command line flags to
    override those values. For example, the following defines a CLI argument
    called `--loader-max-age` that will default to the value of the `max_age`
    key in the user configuration file if it exists, otherwise it defaults to 0:

        parser.add_argument(
            &#39;--loader-max-age&#39;,
            metavar=&#39;SECS&#39;,
            type=int,
            default=cfg(&#39;max_age&#39;, type=Int, default=0),
            help=&#39;maximum age of the cache&#39;)

    **Note:** A plug-in author must not invoke the `parse_args` or
    `parse_known_args` on the `parser` object provided in the constructor. The
    `PluginManager` is responsible for managing this and maintaining the state
    associated with argument processing. The constructor should be used to only
    register new CLI arguments and invoke the superclass&#39;s constructor.
    &#34;&#34;&#34;

    def __init__(self, parser, cfg):
        self.parser = parser
        self.cfg = cfg

    def instantiate(self, args):
        &#34;&#34;&#34;Returns an object created with options and arguments defined by the plug-in.

        The `PluginManager` will invoke this method after it has completed
        parsing the command line arguments that the plug-in defined in the
        constructor. The `args` argument is a populated `argparse.Namespace`
        object that contains the values of any command line arguments provided
        by the user on the CLI.

        This method also has access to the `self.parser` and `self.cfg` objects
        that were provided in the constructor. The `self.cfg` object is useful
        for cases where one does not want to provide a CLI flag for an option
        defined in the configuration file. In this case, when instantiating the
        object, you can pull values for the configuration file.

        The `self.parser` object is useful if one wishes to abort the
        instantiation of the plug-in. `argparse.ArgumentParser.error()` can be
        used to provide an error message to the CLI user and terminate the
        program.  It is perfectly acceptable to terminate the main program from
        within this method. Alternatively, one can raise an exception which will
        also terminate the program.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<code><li><a title="awsrun.plugins.accts.Identity" href="plugins/accts/index.html#awsrun.plugins.accts.Identity">Identity</a></li></code>
<code><li>awsrun.plugins.accts._CachingLoaderPlugin</li></code>
<code><li><a title="awsrun.plugins.accts.azure.AzureCLI" href="plugins/accts/azure.html#awsrun.plugins.accts.azure.AzureCLI">AzureCLI</a></li></code>
<code><li>awsrun.plugins.creds.aws.AbstractCrossAccount</li></code>
<code><li><a title="awsrun.plugins.creds.aws.Profile" href="plugins/creds/aws.html#awsrun.plugins.creds.aws.Profile">Profile</a></li></code>
<code><li><a title="awsrun.plugins.creds.aws.SAML" href="plugins/creds/aws.html#awsrun.plugins.creds.aws.SAML">SAML</a></li></code>
<code><li><a title="awsrun.plugins.creds.azure.Default" href="plugins/creds/azure.html#awsrun.plugins.creds.azure.Default">Default</a></li></code>
<code><li><a title="awsrun.plugins.creds.azure.UsernamePassword" href="plugins/creds/azure.html#awsrun.plugins.creds.azure.UsernamePassword">UsernamePassword</a></li></code>
</ul>
<h3>Methods</h3>
<dl>
<dt id="awsrun.plugmgr.Plugin.instantiate"><code class="name flex">
<span>def <span class="ident">instantiate</span></span>(<span>self, args)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns an object created with options and arguments defined by the plug-in.</p>
<p>The <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> will invoke this method after it has completed
parsing the command line arguments that the plug-in defined in the
constructor. The <code>args</code> argument is a populated <code>argparse.Namespace</code>
object that contains the values of any command line arguments provided
by the user on the CLI.</p>
<p>This method also has access to the <code>self.parser</code> and <code>self.cfg</code> objects
that were provided in the constructor. The <code>self.cfg</code> object is useful
for cases where one does not want to provide a CLI flag for an option
defined in the configuration file. In this case, when instantiating the
object, you can pull values for the configuration file.</p>
<p>The <code>self.parser</code> object is useful if one wishes to abort the
instantiation of the plug-in. <code>argparse.ArgumentParser.error()</code> can be
used to provide an error message to the CLI user and terminate the
program.
It is perfectly acceptable to terminate the main program from
within this method. Alternatively, one can raise an exception which will
also terminate the program.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instantiate(self, args):
    &#34;&#34;&#34;Returns an object created with options and arguments defined by the plug-in.

    The `PluginManager` will invoke this method after it has completed
    parsing the command line arguments that the plug-in defined in the
    constructor. The `args` argument is a populated `argparse.Namespace`
    object that contains the values of any command line arguments provided
    by the user on the CLI.

    This method also has access to the `self.parser` and `self.cfg` objects
    that were provided in the constructor. The `self.cfg` object is useful
    for cases where one does not want to provide a CLI flag for an option
    defined in the configuration file. In this case, when instantiating the
    object, you can pull values for the configuration file.

    The `self.parser` object is useful if one wishes to abort the
    instantiation of the plug-in. `argparse.ArgumentParser.error()` can be
    used to provide an error message to the CLI user and terminate the
    program.  It is perfectly acceptable to terminate the main program from
    within this method. Alternatively, one can raise an exception which will
    also terminate the program.
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="awsrun.plugmgr.PluginManager"><code class="flex name class">
<span>class <span class="ident">PluginManager</span></span>
<span>(</span><span>config, parser, parsed_args, unparsed_argv)</span>
</code></dt>
<dd>
<section class="desc"><p>Manages the loading and instantiation of awsrun plug-ins.</p>
<p>The <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> is responsible for loading and instantiating a <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>
as well as managing the state associated with CLI argument processing as
plug-ins can register their own CLI flags. Users specify plug-ins and the
options to those plugins in their awsrun configuration file. Most options
can also be overridden via CLI flags if desired. See the <code><a title="awsrun.plugmgr" href="#awsrun.plugmgr">awsrun.plugmgr</a></code>
for example usage.</p>
<p>The <code>config</code> argument is a <code><a title="awsrun.config.Config" href="config.html#awsrun.config.Config">Config</a></code> that contains one or more
plug-in specifications (discussed below). <code>parser</code> is a the main CLI
<code>argparse.ArgumentParser</code> that will be provided to plug-ins so they can
define new CLI arguments. <code>parsed_args</code> is a <code>argparse.Namespace</code> containing
the results of CLI argument processing up to this point. And,
<code>unparsed_argv</code> is a list of unprocessed arguments passed on the command
line, which might contain arguments destined for a plug-in.</p>
<p>A plug-in specification identifies the name of the plug-in, the <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>
implementation, and its options. The format of the specification is as
follows:</p>
<pre><code>PLUGIN_NAME:
  plugin: PYTHON_MODULE.CLASSNAME
  options:
    ARG1: VAL1
    ARG2: VAL2
</code></pre>
<p>For example, the following is a sample plug-in specification for the
"Accounts" plug-in:</p>
<pre><code>Accounts:
  plugin: awsrun.plugins.accts.JSON
  options:
    url: "http://www.example.com/accounts"
    max_age: 86400
</code></pre>
<p>The specification must include the <code>plugin</code> key that identifies, via a
dotted string, the Python module concatenated with the name of a <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>
subclass. Plug-ins must be installed in the standard Python path. In the
above example, <code><a title="awsrun.plugins.accts.JSON" href="plugins/accts/index.html#awsrun.plugins.accts.JSON">JSON</a></code> points to a subclass called
<code>JSON</code> in the <code><a title="awsrun.plugins.accts" href="plugins/accts/index.html">awsrun.plugins.accts</a></code> module. The specification can also
optionally include the <code>options</code> key that defines options made available
to the plug-in via an <code><a title="awsrun.config.Config" href="config.html#awsrun.config.Config">Config</a></code> object, which is passed to the
constructor of a <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>. This allows the plug-in to type check values and
use other features of the config module.</p>
<p>Plug-in authors should refer to the documentation for <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code> to understand
how the <code>config</code> and <code>parser</code> interact with each other during the
instantiation of a plug-in.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PluginManager:
    &#34;&#34;&#34;Manages the loading and instantiation of awsrun plug-ins.

    The `PluginManager` is responsible for loading and instantiating a `Plugin`
    as well as managing the state associated with CLI argument processing as
    plug-ins can register their own CLI flags. Users specify plug-ins and the
    options to those plugins in their awsrun configuration file. Most options
    can also be overridden via CLI flags if desired. See the `awsrun.plugmgr`
    for example usage.

    The `config` argument is a `awsrun.config.Config` that contains one or more
    plug-in specifications (discussed below). `parser` is a the main CLI
    `argparse.ArgumentParser` that will be provided to plug-ins so they can
    define new CLI arguments. `parsed_args` is a `argparse.Namespace` containing
    the results of CLI argument processing up to this point. And,
    `unparsed_argv` is a list of unprocessed arguments passed on the command
    line, which might contain arguments destined for a plug-in.

    A plug-in specification identifies the name of the plug-in, the `Plugin`
    implementation, and its options. The format of the specification is as
    follows:

        PLUGIN_NAME:
          plugin: PYTHON_MODULE.CLASSNAME
          options:
            ARG1: VAL1
            ARG2: VAL2

    For example, the following is a sample plug-in specification for the
    &#34;Accounts&#34; plug-in:

        Accounts:
          plugin: awsrun.plugins.accts.JSON
          options:
            url: &#34;http://www.example.com/accounts&#34;
            max_age: 86400

    The specification must include the `plugin` key that identifies, via a
    dotted string, the Python module concatenated with the name of a `Plugin`
    subclass. Plug-ins must be installed in the standard Python path. In the
    above example, `awsrun.plugins.accts.JSON` points to a subclass called
    `JSON` in the `awsrun.plugins.accts` module. The specification can also
    optionally include the `options` key that defines options made available
    to the plug-in via an `awsrun.config.Config` object, which is passed to the
    constructor of a `Plugin`. This allows the plug-in to type check values and
    use other features of the config module.

    Plug-in authors should refer to the documentation for `Plugin` to understand
    how the `config` and `parser` interact with each other during the
    instantiation of a plug-in.
    &#34;&#34;&#34;

    def __init__(self, config, parser, parsed_args, unparsed_argv):
        self._config = config
        self._parser = parser
        self._plugins = {}

        self.args = parsed_args
        &#34;&#34;&#34;A `argparse.Namespace` that parsed plug-in arguments are added.

        After each call to `PluginManager.parse_args`, this namespace is updated
        with any unparsed arguments consumed by a `Plugin`. In addition, when
        the `PluginManager` instantiates a plug-in, this namespace is provided
        to the plug-in, so it has access to its parsed arguments.
        &#34;&#34;&#34;

        self.remaining_argv = unparsed_argv
        &#34;&#34;&#34;A list of unparsed command line arguments remaining to be parsed.

        At the start of the `PluginManager`, this contains any command line
        arguments that might be intended for one or more plug-ins. It is updated
        after each successive call to `PluginManager.parse_args`. If a plug-in
        consumes arguments, they are transferred from this unparsed list to the
        parsed `PluginManager.args` namespace.
        &#34;&#34;&#34;

    def parse_args(self, *keys, default=None):
        &#34;&#34;&#34;Load the plug-in and parse command line arguments passed via the CLI.

        This method does not return anything, nor does it instantiate the
        plug-in. It only loads the plug-in class and performs command line
        argument processing for the `Plugin`. It is provided to allow one to
        separate the parsing of all line arguments from the instantiation of
        plug-ins. If this method is not explicitly called by the user, then it
        will be implicitly called when `PluginManager.instantiate` is called.
        See the `awsrun.plugmgr` documentation for the rationale.

        The `keys` varargs specifies the path to the plug-in specification
        contained with the configuration. See the `PluginManager` documentation
        for details on the plug-in specification. If the path does not exist,
        then the value of `default` is used instead. This default value must be
        a dotted string pointing to a subclass of `Plugin`. For example:

            pm = PluginManager(config, parser, parsed_args, unparsed_argv)
            pm.parse_args(&#39;Accounts&#39;, default=&#39;awsrun.plugins.accts.Identity&#39;)

        If the `Accounts` key does not exist in the configuration, then the
        `awsrun.plugins.accts.Identity` plug-in will be used instead.
        &#34;&#34;&#34;
        path = self._config.get(*keys, &#34;plugin&#34;) or default
        LOG.info(&#34;loading plug-in: %s&#34;, path)

        try:
            plugin_class = load_dotted_object(path)

        except ImportError as e:
            raise ValueError(f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: {e}&#34;) from e

        if not (isclass(plugin_class) and issubclass(plugin_class, Plugin)):
            raise TypeError(
                f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: &#39;{path}&#39; is not a {Plugin}&#34;
            )

        # Create a new config callable that points directly to the options
        # stored in the configuration. This will make it easy for plugin authors
        # to query the config without having to specify the key path leading up
        # to the options section of the config.
        cfg = partial(self._config.get, *keys, &#34;options&#34;)

        plugin = plugin_class(self._parser, cfg)
        self.args, self.remaining_argv = self._parser.parse_known_args(
            self.remaining_argv, self.args
        )
        LOG.info(&#34;parsed args=%s remaining args=%s&#34;, self.args, self.remaining_argv)

        self._plugins[keys] = plugin

    def instantiate(self, *keys, default=None, must_be=None):
        &#34;&#34;&#34;Returns the instantiated plug-in.

        This method ultimately returns the value from `Plugin.instantiate`,
        which is passed a reference to the `PluginManager.args` object, so the
        plug-in can use any parsed command line arguments it had requested. It
        is usual, but not necessary, to invoke `PluginManager.parse_args` for
        each plug-in before calling this method. This allows all command line
        processing, and more important errors, to be complete before the actual
        instantiation of any plug-ins.

        The `keys` varargs specifies the path to the plug-in specification
        contained with the configuration. See the `PluginManager` documentation
        for details on the plug-in specification. If the path does not exist,
        then the value of `default` is used instead. This default value must be
        a dotted string pointing to a subclass of `Plugin`. For example:

            pm = PluginManager(config, parser, parsed_args, unparsed_argv)
            acct_loader = pm.instantiate(
                &#39;Accounts&#39;,
                must_be=AccountLoader,
                default=&#39;awsrun.plugins.accts.Identity&#39;)

        If the `Accounts` key does not exist in the configuration, then the
        `awsrun.plugins.accts.Identity` plug-in will be used instead. If
        `must_be` is provided, the returned value from `Plugin.instantiate` must
        be an instance of the type specified, otherwise a `TypeError` is raised.
        If `must_be` is not provided, the returned object can be of any type.
        &#34;&#34;&#34;
        if keys not in self._plugins:
            self.parse_args(*keys, default)

        instance = self._plugins[keys].instantiate(self.args)

        if must_be and not isinstance(instance, must_be):
            raise TypeError(
                f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: plugin did not build a {must_be}&#34;
            )

        return instance</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="awsrun.plugmgr.PluginManager.args"><code class="name">var <span class="ident">args</span></code></dt>
<dd>
<section class="desc"><p>A <code>argparse.Namespace</code> that parsed plug-in arguments are added.</p>
<p>After each call to <code><a title="awsrun.plugmgr.PluginManager.parse_args" href="#awsrun.plugmgr.PluginManager.parse_args">PluginManager.parse_args()</a></code>, this namespace is updated
with any unparsed arguments consumed by a <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>. In addition, when
the <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> instantiates a plug-in, this namespace is provided
to the plug-in, so it has access to its parsed arguments.</p></section>
</dd>
<dt id="awsrun.plugmgr.PluginManager.remaining_argv"><code class="name">var <span class="ident">remaining_argv</span></code></dt>
<dd>
<section class="desc"><p>A list of unparsed command line arguments remaining to be parsed.</p>
<p>At the start of the <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code>, this contains any command line
arguments that might be intended for one or more plug-ins. It is updated
after each successive call to <code><a title="awsrun.plugmgr.PluginManager.parse_args" href="#awsrun.plugmgr.PluginManager.parse_args">PluginManager.parse_args()</a></code>. If a plug-in
consumes arguments, they are transferred from this unparsed list to the
parsed <code><a title="awsrun.plugmgr.PluginManager.args" href="#awsrun.plugmgr.PluginManager.args">PluginManager.args</a></code> namespace.</p></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="awsrun.plugmgr.PluginManager.parse_args"><code class="name flex">
<span>def <span class="ident">parse_args</span></span>(<span>self, *keys, default=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Load the plug-in and parse command line arguments passed via the CLI.</p>
<p>This method does not return anything, nor does it instantiate the
plug-in. It only loads the plug-in class and performs command line
argument processing for the <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>. It is provided to allow one to
separate the parsing of all line arguments from the instantiation of
plug-ins. If this method is not explicitly called by the user, then it
will be implicitly called when <code><a title="awsrun.plugmgr.PluginManager.instantiate" href="#awsrun.plugmgr.PluginManager.instantiate">PluginManager.instantiate()</a></code> is called.
See the <code><a title="awsrun.plugmgr" href="#awsrun.plugmgr">awsrun.plugmgr</a></code> documentation for the rationale.</p>
<p>The <code>keys</code> varargs specifies the path to the plug-in specification
contained with the configuration. See the <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> documentation
for details on the plug-in specification. If the path does not exist,
then the value of <code>default</code> is used instead. This default value must be
a dotted string pointing to a subclass of <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>. For example:</p>
<pre><code>pm = PluginManager(config, parser, parsed_args, unparsed_argv)
pm.parse_args('Accounts', default='awsrun.plugins.accts.Identity')
</code></pre>
<p>If the <code>Accounts</code> key does not exist in the configuration, then the
<code><a title="awsrun.plugins.accts.Identity" href="plugins/accts/index.html#awsrun.plugins.accts.Identity">Identity</a></code> plug-in will be used instead.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_args(self, *keys, default=None):
    &#34;&#34;&#34;Load the plug-in and parse command line arguments passed via the CLI.

    This method does not return anything, nor does it instantiate the
    plug-in. It only loads the plug-in class and performs command line
    argument processing for the `Plugin`. It is provided to allow one to
    separate the parsing of all line arguments from the instantiation of
    plug-ins. If this method is not explicitly called by the user, then it
    will be implicitly called when `PluginManager.instantiate` is called.
    See the `awsrun.plugmgr` documentation for the rationale.

    The `keys` varargs specifies the path to the plug-in specification
    contained with the configuration. See the `PluginManager` documentation
    for details on the plug-in specification. If the path does not exist,
    then the value of `default` is used instead. This default value must be
    a dotted string pointing to a subclass of `Plugin`. For example:

        pm = PluginManager(config, parser, parsed_args, unparsed_argv)
        pm.parse_args(&#39;Accounts&#39;, default=&#39;awsrun.plugins.accts.Identity&#39;)

    If the `Accounts` key does not exist in the configuration, then the
    `awsrun.plugins.accts.Identity` plug-in will be used instead.
    &#34;&#34;&#34;
    path = self._config.get(*keys, &#34;plugin&#34;) or default
    LOG.info(&#34;loading plug-in: %s&#34;, path)

    try:
        plugin_class = load_dotted_object(path)

    except ImportError as e:
        raise ValueError(f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: {e}&#34;) from e

    if not (isclass(plugin_class) and issubclass(plugin_class, Plugin)):
        raise TypeError(
            f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: &#39;{path}&#39; is not a {Plugin}&#34;
        )

    # Create a new config callable that points directly to the options
    # stored in the configuration. This will make it easy for plugin authors
    # to query the config without having to specify the key path leading up
    # to the options section of the config.
    cfg = partial(self._config.get, *keys, &#34;options&#34;)

    plugin = plugin_class(self._parser, cfg)
    self.args, self.remaining_argv = self._parser.parse_known_args(
        self.remaining_argv, self.args
    )
    LOG.info(&#34;parsed args=%s remaining args=%s&#34;, self.args, self.remaining_argv)

    self._plugins[keys] = plugin</code></pre>
</details>
</dd>
<dt id="awsrun.plugmgr.PluginManager.instantiate"><code class="name flex">
<span>def <span class="ident">instantiate</span></span>(<span>self, *keys, default=None, must_be=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the instantiated plug-in.</p>
<p>This method ultimately returns the value from <code><a title="awsrun.plugmgr.Plugin.instantiate" href="#awsrun.plugmgr.Plugin.instantiate">Plugin.instantiate()</a></code>,
which is passed a reference to the <code><a title="awsrun.plugmgr.PluginManager.args" href="#awsrun.plugmgr.PluginManager.args">PluginManager.args</a></code> object, so the
plug-in can use any parsed command line arguments it had requested. It
is usual, but not necessary, to invoke <code><a title="awsrun.plugmgr.PluginManager.parse_args" href="#awsrun.plugmgr.PluginManager.parse_args">PluginManager.parse_args()</a></code> for
each plug-in before calling this method. This allows all command line
processing, and more important errors, to be complete before the actual
instantiation of any plug-ins.</p>
<p>The <code>keys</code> varargs specifies the path to the plug-in specification
contained with the configuration. See the <code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code> documentation
for details on the plug-in specification. If the path does not exist,
then the value of <code>default</code> is used instead. This default value must be
a dotted string pointing to a subclass of <code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code>. For example:</p>
<pre><code>pm = PluginManager(config, parser, parsed_args, unparsed_argv)
acct_loader = pm.instantiate(
    'Accounts',
    must_be=AccountLoader,
    default='awsrun.plugins.accts.Identity')
</code></pre>
<p>If the <code>Accounts</code> key does not exist in the configuration, then the
<code><a title="awsrun.plugins.accts.Identity" href="plugins/accts/index.html#awsrun.plugins.accts.Identity">Identity</a></code> plug-in will be used instead. If
<code>must_be</code> is provided, the returned value from <code><a title="awsrun.plugmgr.Plugin.instantiate" href="#awsrun.plugmgr.Plugin.instantiate">Plugin.instantiate()</a></code> must
be an instance of the type specified, otherwise a <code>TypeError</code> is raised.
If <code>must_be</code> is not provided, the returned object can be of any type.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def instantiate(self, *keys, default=None, must_be=None):
    &#34;&#34;&#34;Returns the instantiated plug-in.

    This method ultimately returns the value from `Plugin.instantiate`,
    which is passed a reference to the `PluginManager.args` object, so the
    plug-in can use any parsed command line arguments it had requested. It
    is usual, but not necessary, to invoke `PluginManager.parse_args` for
    each plug-in before calling this method. This allows all command line
    processing, and more important errors, to be complete before the actual
    instantiation of any plug-ins.

    The `keys` varargs specifies the path to the plug-in specification
    contained with the configuration. See the `PluginManager` documentation
    for details on the plug-in specification. If the path does not exist,
    then the value of `default` is used instead. This default value must be
    a dotted string pointing to a subclass of `Plugin`. For example:

        pm = PluginManager(config, parser, parsed_args, unparsed_argv)
        acct_loader = pm.instantiate(
            &#39;Accounts&#39;,
            must_be=AccountLoader,
            default=&#39;awsrun.plugins.accts.Identity&#39;)

    If the `Accounts` key does not exist in the configuration, then the
    `awsrun.plugins.accts.Identity` plug-in will be used instead. If
    `must_be` is provided, the returned value from `Plugin.instantiate` must
    be an instance of the type specified, otherwise a `TypeError` is raised.
    If `must_be` is not provided, the returned object can be of any type.
    &#34;&#34;&#34;
    if keys not in self._plugins:
        self.parse_args(*keys, default)

    instance = self._plugins[keys].instantiate(self.args)

    if must_be and not isinstance(instance, must_be):
        raise TypeError(
            f&#34;Error in config: {&#39;-&gt;&#39;.join(keys)}-&gt;plugin: plugin did not build a {must_be}&#34;
        )

    return instance</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#overview">Overview</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="awsrun" href="index.html">awsrun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="awsrun.plugmgr.load_dotted_object" href="#awsrun.plugmgr.load_dotted_object">load_dotted_object</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="awsrun.plugmgr.Plugin" href="#awsrun.plugmgr.Plugin">Plugin</a></code></h4>
<ul class="">
<li><code><a title="awsrun.plugmgr.Plugin.instantiate" href="#awsrun.plugmgr.Plugin.instantiate">instantiate</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="awsrun.plugmgr.PluginManager" href="#awsrun.plugmgr.PluginManager">PluginManager</a></code></h4>
<ul class="">
<li><code><a title="awsrun.plugmgr.PluginManager.parse_args" href="#awsrun.plugmgr.PluginManager.parse_args">parse_args</a></code></li>
<li><code><a title="awsrun.plugmgr.PluginManager.instantiate" href="#awsrun.plugmgr.PluginManager.instantiate">instantiate</a></code></li>
<li><code><a title="awsrun.plugmgr.PluginManager.args" href="#awsrun.plugmgr.PluginManager.args">args</a></code></li>
<li><code><a title="awsrun.plugmgr.PluginManager.remaining_argv" href="#awsrun.plugmgr.PluginManager.remaining_argv">remaining_argv</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>