<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>awsrun.argparse API documentation</title>
<meta name="description" content="Provides additional actions and formatters for the builtin argparse module." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- <link href="/awsrun/webfonts.css" rel="stylesheet"> -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=M+PLUS+1:wght@400;700&family=M+PLUS+Code+Latin:wght@400;600&display=swap" rel="stylesheet">
<style>
body {
font-size: 15px;
font-family: 'M PLUS 1', sans-serif;
}
code {
font-family: 'M PLUS Code Latin', monospace;
}
#content {
max-width: 110ch;
}
/* `Text` size and code blocks in main body */
section code {
font-size: 15px;
}
/* Line height for code blocks in main body */
pre code {
line-height: 1.3em;
}
/* "expand source code" text */
details {
font-size: 13px;
}
code.name {
font-size: 1.0em;
}
dt {
font-weight: bold;
}
h4 {
font-weight: bold;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>awsrun.argparse</code></h1>
</header>
<section id="section-intro">
<p>Provides additional actions and formatters for the builtin argparse module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright 2019 FMR LLC &lt;opensource@fidelity.com&gt;
#
# SPDX-License-Identifier: MIT
#
&#34;&#34;&#34;Provides additional actions and formatters for the builtin argparse module.&#34;&#34;&#34;

import argparse
import builtins
import re

from functools import wraps


class RawAndDefaultsFormatter(
    argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter
):
    &#34;&#34;&#34;Mixin of ArgumentDefaultsHelpFormatter and RawDescriptionHelpFormatter.

    The argparse API does not allow for easy combinations of help formatters.
    This class combines the raw formatter along with the default args formatter,
    which is used by awsrun CLI.
    &#34;&#34;&#34;


class AppendWithoutDefault(argparse.Action):
    &#34;&#34;&#34;Argparse action to append to a list without the default.

    Out of the box, when using argparse to `append` options to a list, if a
    default has been provided in `add_argument`, then any options provided on
    the command line will be appended to that default list. For example, notice
    that `central` remains in the list:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=&#39;append&#39;, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;central&#39;, &#39;east&#39;, &#39;west&#39;])

    This class provides an argparse action that will only use the default value
    if no other values were provided on the command line. For example:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=AppendWithoutDefault, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;east&#39;, &#39;west&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;&#39;)
        Namespace(region=[&#39;central&#39;])
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.has_been_called = False
        super().__init__(*args, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        current = [] if not self.has_been_called else getattr(namespace, self.dest)
        current.append(values)
        setattr(namespace, self.dest, current)
        self.has_been_called = True


class AppendAttributeValuePair(argparse.Action):
    &#34;&#34;&#34;Argparse action to construct a dict of key/value pairs.

    Parses command line options into a dict of key/value pairs where multiple
    options and/or values are appended to the appropriate key/value pair. Option
    must be in either `name=val1,val2,etc` format or `name=type:val1,val2,etc`
    where `type` is one of `str`, `int`, `float`, or `bool`. The first format
    assumes a type of `str`. Examples will best illustrate use:

        &gt;&gt;&gt; import argparse
        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--flag&#39;, &#39;-f&#39;, action=AppendAttributeValuePair)
        &gt;&gt;&gt; def test(arg_string):
        ...   return parser.parse_args(arg_string.split()).flag
        ...
        &gt;&gt;&gt; test(&#39;-f env=prod&#39;)
        {&#39;env&#39;: [&#39;prod&#39;]}

    More than one value can be provided on the right-hand side of the `=`:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The option can be provided multiple times. If the left-hand side of the `=`
    is different, a new key is added to the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod -f status=active&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;], &#39;status&#39;: [&#39;active&#39;]}

    If the left-hand side is the same as a previous, the values are appended to
    the existing key in the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev -f env=qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The type of the comma separated values defaults to strings, but can be
    converted to ints, floats, or bools:

        &gt;&gt;&gt; test(&#39;-f level=1,2,3&#39;)
        {&#39;level&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]}

        &gt;&gt;&gt; test(&#39;-f level=int:1,2,3&#39;)
        {&#39;level&#39;: [1, 2, 3]}

        &gt;&gt;&gt; test(&#39;-f level=float:1,2,3&#39;)
        {&#39;level&#39;: [1.0, 2.0, 3.0]}

        &gt;&gt;&gt; test(&#39;-f level=bool:1,2,3&#39;)
        {&#39;level&#39;: [True, False, False]}
    &#34;&#34;&#34;

    def __call__(self, parser, namespace, values, option_string=None):
        match = re.match(r&#34;([^=]+)=(?:(str|int|float|bool):)?(.+)&#34;, values)
        if not match:
            parser.error(f&#34;{option_string}: expected attr=val1,val2,etc&#34;)

        name, value_type, comma_sep_values = match.groups()
        cast = from_str_to(value_type)

        # Note: getattr below will always return a value because the argparse
        # Action sets the namespace attribute with a default value. That default
        # value may be None or a user-supplied dict. This means we can&#39;t use the
        # default parameter to getattr as the attribute will always exist.
        d = getattr(namespace, self.dest)

        # If it is None, then create a dict to store the parsed results.
        if d is None:
            d = {}

        # Normally I would use a defaultdict(list) when checking for a key
        # and setting a default value, but this cannot be used here as the
        # default provided by the user via parser.add_argument(default=...)
        # may be a regular dict, so we have to explicitly check for the name.
        if name not in d:
            d[name] = []

        try:
            d[name].extend(cast(v.strip()) for v in comma_sep_values.split(&#34;,&#34;))

        except ValueError:  # cast might throw an error
            parser.error(f&#34;{option_string}: invalid {value_type} in {match.group()}&#34;)

        setattr(namespace, self.dest, d)


# This is, admittedly, a hack as we are adding a wrapper around a method on a
# private class that is not exposed in argparse module. This is just used for a
# safety check to ensure the same option flag name is not used across _any_
# parsers defined in a Python session unless they are in the `exclude` list.
# This is used because there are many layers of argument parsing that take place
# with the awsrun CLI (see cli.py for comment about argument parsing).
def prevent_option_reuse(exclude=None):
    &#34;&#34;&#34;Prevent reuse of flags across any instance of ArgumentParser.

    By default, `argparse.ArgumentParser` will raise an ArgumentError if the
    same option flag name or positional parameter name is registered to the same
    parser. After this function has been invoked, the option flag names cannot
    be reused across *any* instance of `argparse.ArgumentParser` unless they
    they are in the `exclude` list.
    &#34;&#34;&#34;
    seen = set()
    exclude = [] if exclude is None else exclude

    # pylint: disable=protected-access
    original = argparse._ActionsContainer.add_argument

    @wraps(original)
    def wrapper(self, *args, **kwargs):
        for arg in args:
            if arg in seen:
                raise argparse.ArgumentError(None, f&#34;option flag already used: {arg}&#34;)
            if any(arg.startswith(p) for p in self.prefix_chars) and arg not in exclude:
                seen.add(arg)
        return original(self, *args, **kwargs)

    argparse._ActionsContainer.add_argument = wrapper


def from_str_to(type_):
    &#34;&#34;&#34;Return a cast function to convert a string to a builtin type.

    The `type` parameter is the name of the type as a string. Returns the
    builtin Python cast function if `type` is &#34;str&#34;, &#34;int&#34;, or &#34;float&#34;. If
    `type` is &#34;bool&#34;, the returned cast function will return `True` for the
    values &#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, and &#34;1&#34; (case insensitive), otherwise it will
    return `False`. For any other `type` specified, the builtin `str`
    function is returned.

        &gt;&gt;&gt; f = from_str_to(&#34;str&#34;)
        &gt;&gt;&gt; f(&#34;hello&#34;)
        &#34;hello&#34;

        &gt;&gt;&gt; f = from_str_to(&#34;int&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10

        &gt;&gt;&gt; f = from_str_to(&#34;float&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10.0

        &gt;&gt;&gt; f = from_str_to(&#34;bool&#34;)
        &gt;&gt;&gt; [f(s) for s in [&#39;yes&#39;, &#39;no&#39;, &#39;true&#39;, &#39;false&#39;]]
        [True, False, True, False]
    &#34;&#34;&#34;
    if type_ in (&#34;str&#34;, &#34;int&#34;, &#34;float&#34;):
        return getattr(builtins, type_)
    if type_ == &#34;bool&#34;:
        return lambda s: s.lower() in (&#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, &#34;True&#34;, &#34;1&#34;)
    return str</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="awsrun.argparse.prevent_option_reuse"><code class="name flex">
<span>def <span class="ident">prevent_option_reuse</span></span>(<span>exclude=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Prevent reuse of flags across any instance of ArgumentParser.</p>
<p>By default, <code>argparse.ArgumentParser</code> will raise an ArgumentError if the
same option flag name or positional parameter name is registered to the same
parser. After this function has been invoked, the option flag names cannot
be reused across <em>any</em> instance of <code>argparse.ArgumentParser</code> unless they
they are in the <code>exclude</code> list.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prevent_option_reuse(exclude=None):
    &#34;&#34;&#34;Prevent reuse of flags across any instance of ArgumentParser.

    By default, `argparse.ArgumentParser` will raise an ArgumentError if the
    same option flag name or positional parameter name is registered to the same
    parser. After this function has been invoked, the option flag names cannot
    be reused across *any* instance of `argparse.ArgumentParser` unless they
    they are in the `exclude` list.
    &#34;&#34;&#34;
    seen = set()
    exclude = [] if exclude is None else exclude

    # pylint: disable=protected-access
    original = argparse._ActionsContainer.add_argument

    @wraps(original)
    def wrapper(self, *args, **kwargs):
        for arg in args:
            if arg in seen:
                raise argparse.ArgumentError(None, f&#34;option flag already used: {arg}&#34;)
            if any(arg.startswith(p) for p in self.prefix_chars) and arg not in exclude:
                seen.add(arg)
        return original(self, *args, **kwargs)

    argparse._ActionsContainer.add_argument = wrapper</code></pre>
</details>
</dd>
<dt id="awsrun.argparse.from_str_to"><code class="name flex">
<span>def <span class="ident">from_str_to</span></span>(<span>type_)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a cast function to convert a string to a builtin type.</p>
<p>The <code>type</code> parameter is the name of the type as a string. Returns the
builtin Python cast function if <code>type</code> is "str", "int", or "float". If
<code>type</code> is "bool", the returned cast function will return <code>True</code> for the
values "y", "yes", "true", and "1" (case insensitive), otherwise it will
return <code>False</code>. For any other <code>type</code> specified, the builtin <code>str</code>
function is returned.</p>
<pre><code>&gt;&gt;&gt; f = from_str_to("str")
&gt;&gt;&gt; f("hello")
"hello"

&gt;&gt;&gt; f = from_str_to("int")
&gt;&gt;&gt; f("10")
10

&gt;&gt;&gt; f = from_str_to("float")
&gt;&gt;&gt; f("10")
10.0

&gt;&gt;&gt; f = from_str_to("bool")
&gt;&gt;&gt; [f(s) for s in ['yes', 'no', 'true', 'false']]
[True, False, True, False]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_str_to(type_):
    &#34;&#34;&#34;Return a cast function to convert a string to a builtin type.

    The `type` parameter is the name of the type as a string. Returns the
    builtin Python cast function if `type` is &#34;str&#34;, &#34;int&#34;, or &#34;float&#34;. If
    `type` is &#34;bool&#34;, the returned cast function will return `True` for the
    values &#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, and &#34;1&#34; (case insensitive), otherwise it will
    return `False`. For any other `type` specified, the builtin `str`
    function is returned.

        &gt;&gt;&gt; f = from_str_to(&#34;str&#34;)
        &gt;&gt;&gt; f(&#34;hello&#34;)
        &#34;hello&#34;

        &gt;&gt;&gt; f = from_str_to(&#34;int&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10

        &gt;&gt;&gt; f = from_str_to(&#34;float&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10.0

        &gt;&gt;&gt; f = from_str_to(&#34;bool&#34;)
        &gt;&gt;&gt; [f(s) for s in [&#39;yes&#39;, &#39;no&#39;, &#39;true&#39;, &#39;false&#39;]]
        [True, False, True, False]
    &#34;&#34;&#34;
    if type_ in (&#34;str&#34;, &#34;int&#34;, &#34;float&#34;):
        return getattr(builtins, type_)
    if type_ == &#34;bool&#34;:
        return lambda s: s.lower() in (&#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, &#34;True&#34;, &#34;1&#34;)
    return str</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="awsrun.argparse.RawAndDefaultsFormatter"><code class="flex name class">
<span>class <span class="ident">RawAndDefaultsFormatter</span></span>
<span>(</span><span>prog, indent_increment=2, max_help_position=24, width=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Mixin of ArgumentDefaultsHelpFormatter and RawDescriptionHelpFormatter.</p>
<p>The argparse API does not allow for easy combinations of help formatters.
This class combines the raw formatter along with the default args formatter,
which is used by awsrun CLI.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawAndDefaultsFormatter(
    argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter
):
    &#34;&#34;&#34;Mixin of ArgumentDefaultsHelpFormatter and RawDescriptionHelpFormatter.

    The argparse API does not allow for easy combinations of help formatters.
    This class combines the raw formatter along with the default args formatter,
    which is used by awsrun CLI.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li>argparse.ArgumentDefaultsHelpFormatter</li></code>
<code><li>argparse.RawDescriptionHelpFormatter</li></code>
<code><li>argparse.HelpFormatter</li></code>
</ul>
</dd>
<dt id="awsrun.argparse.AppendWithoutDefault"><code class="flex name class">
<span>class <span class="ident">AppendWithoutDefault</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Argparse action to append to a list without the default.</p>
<p>Out of the box, when using argparse to <code>append</code> options to a list, if a
default has been provided in <code>add_argument</code>, then any options provided on
the command line will be appended to that default list. For example, notice
that <code>central</code> remains in the list:</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--region', action='append', default=['central'])
&gt;&gt;&gt; parser.parse_args('--region east --region west'.split())
Namespace(region=['central', 'east', 'west'])
</code></pre>
<p>This class provides an argparse action that will only use the default value
if no other values were provided on the command line. For example:</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--region', action=AppendWithoutDefault, default=['central'])
&gt;&gt;&gt; parser.parse_args('--region east --region west'.split())
Namespace(region=['east', 'west'])
&gt;&gt;&gt; parser.parse_args('')
Namespace(region=['central'])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppendWithoutDefault(argparse.Action):
    &#34;&#34;&#34;Argparse action to append to a list without the default.

    Out of the box, when using argparse to `append` options to a list, if a
    default has been provided in `add_argument`, then any options provided on
    the command line will be appended to that default list. For example, notice
    that `central` remains in the list:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=&#39;append&#39;, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;central&#39;, &#39;east&#39;, &#39;west&#39;])

    This class provides an argparse action that will only use the default value
    if no other values were provided on the command line. For example:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=AppendWithoutDefault, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;east&#39;, &#39;west&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;&#39;)
        Namespace(region=[&#39;central&#39;])
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.has_been_called = False
        super().__init__(*args, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        current = [] if not self.has_been_called else getattr(namespace, self.dest)
        current.append(values)
        setattr(namespace, self.dest, current)
        self.has_been_called = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li>argparse.Action</li></code>
<code><li>argparse._AttributeHolder</li></code>
</ul>
</dd>
<dt id="awsrun.argparse.AppendAttributeValuePair"><code class="flex name class">
<span>class <span class="ident">AppendAttributeValuePair</span></span>
<span>(</span><span>option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Argparse action to construct a dict of key/value pairs.</p>
<p>Parses command line options into a dict of key/value pairs where multiple
options and/or values are appended to the appropriate key/value pair. Option
must be in either <code>name=val1,val2,etc</code> format or <code>name=type:val1,val2,etc</code>
where <code>type</code> is one of <code>str</code>, <code>int</code>, <code>float</code>, or <code>bool</code>. The first format
assumes a type of <code>str</code>. Examples will best illustrate use:</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--flag', '-f', action=AppendAttributeValuePair)
&gt;&gt;&gt; def test(arg_string):
...   return parser.parse_args(arg_string.split()).flag
...
&gt;&gt;&gt; test('-f env=prod')
{'env': ['prod']}
</code></pre>
<p>More than one value can be provided on the right-hand side of the <code>=</code>:</p>
<pre><code>&gt;&gt;&gt; test('-f env=dev,qa,prod')
{'env': ['dev', 'qa', 'prod']}
</code></pre>
<p>The option can be provided multiple times. If the left-hand side of the <code>=</code>
is different, a new key is added to the dict:</p>
<pre><code>&gt;&gt;&gt; test('-f env=dev,qa,prod -f status=active')
{'env': ['dev', 'qa', 'prod'], 'status': ['active']}
</code></pre>
<p>If the left-hand side is the same as a previous, the values are appended to
the existing key in the dict:</p>
<pre><code>&gt;&gt;&gt; test('-f env=dev -f env=qa,prod')
{'env': ['dev', 'qa', 'prod']}
</code></pre>
<p>The type of the comma separated values defaults to strings, but can be
converted to ints, floats, or bools:</p>
<pre><code>&gt;&gt;&gt; test('-f level=1,2,3')
{'level': ['1', '2', '3']}

&gt;&gt;&gt; test('-f level=int:1,2,3')
{'level': [1, 2, 3]}

&gt;&gt;&gt; test('-f level=float:1,2,3')
{'level': [1.0, 2.0, 3.0]}

&gt;&gt;&gt; test('-f level=bool:1,2,3')
{'level': [True, False, False]}
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppendAttributeValuePair(argparse.Action):
    &#34;&#34;&#34;Argparse action to construct a dict of key/value pairs.

    Parses command line options into a dict of key/value pairs where multiple
    options and/or values are appended to the appropriate key/value pair. Option
    must be in either `name=val1,val2,etc` format or `name=type:val1,val2,etc`
    where `type` is one of `str`, `int`, `float`, or `bool`. The first format
    assumes a type of `str`. Examples will best illustrate use:

        &gt;&gt;&gt; import argparse
        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--flag&#39;, &#39;-f&#39;, action=AppendAttributeValuePair)
        &gt;&gt;&gt; def test(arg_string):
        ...   return parser.parse_args(arg_string.split()).flag
        ...
        &gt;&gt;&gt; test(&#39;-f env=prod&#39;)
        {&#39;env&#39;: [&#39;prod&#39;]}

    More than one value can be provided on the right-hand side of the `=`:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The option can be provided multiple times. If the left-hand side of the `=`
    is different, a new key is added to the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod -f status=active&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;], &#39;status&#39;: [&#39;active&#39;]}

    If the left-hand side is the same as a previous, the values are appended to
    the existing key in the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev -f env=qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The type of the comma separated values defaults to strings, but can be
    converted to ints, floats, or bools:

        &gt;&gt;&gt; test(&#39;-f level=1,2,3&#39;)
        {&#39;level&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]}

        &gt;&gt;&gt; test(&#39;-f level=int:1,2,3&#39;)
        {&#39;level&#39;: [1, 2, 3]}

        &gt;&gt;&gt; test(&#39;-f level=float:1,2,3&#39;)
        {&#39;level&#39;: [1.0, 2.0, 3.0]}

        &gt;&gt;&gt; test(&#39;-f level=bool:1,2,3&#39;)
        {&#39;level&#39;: [True, False, False]}
    &#34;&#34;&#34;

    def __call__(self, parser, namespace, values, option_string=None):
        match = re.match(r&#34;([^=]+)=(?:(str|int|float|bool):)?(.+)&#34;, values)
        if not match:
            parser.error(f&#34;{option_string}: expected attr=val1,val2,etc&#34;)

        name, value_type, comma_sep_values = match.groups()
        cast = from_str_to(value_type)

        # Note: getattr below will always return a value because the argparse
        # Action sets the namespace attribute with a default value. That default
        # value may be None or a user-supplied dict. This means we can&#39;t use the
        # default parameter to getattr as the attribute will always exist.
        d = getattr(namespace, self.dest)

        # If it is None, then create a dict to store the parsed results.
        if d is None:
            d = {}

        # Normally I would use a defaultdict(list) when checking for a key
        # and setting a default value, but this cannot be used here as the
        # default provided by the user via parser.add_argument(default=...)
        # may be a regular dict, so we have to explicitly check for the name.
        if name not in d:
            d[name] = []

        try:
            d[name].extend(cast(v.strip()) for v in comma_sep_values.split(&#34;,&#34;))

        except ValueError:  # cast might throw an error
            parser.error(f&#34;{option_string}: invalid {value_type} in {match.group()}&#34;)

        setattr(namespace, self.dest, d)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li>argparse.Action</li></code>
<code><li>argparse._AttributeHolder</li></code>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="awsrun" href="index.html">awsrun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="awsrun.argparse.prevent_option_reuse" href="#awsrun.argparse.prevent_option_reuse">prevent_option_reuse</a></code></li>
<li><code><a title="awsrun.argparse.from_str_to" href="#awsrun.argparse.from_str_to">from_str_to</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="awsrun.argparse.RawAndDefaultsFormatter" href="#awsrun.argparse.RawAndDefaultsFormatter">RawAndDefaultsFormatter</a></code></h4>
</li>
<li>
<h4><code><a title="awsrun.argparse.AppendWithoutDefault" href="#awsrun.argparse.AppendWithoutDefault">AppendWithoutDefault</a></code></h4>
</li>
<li>
<h4><code><a title="awsrun.argparse.AppendAttributeValuePair" href="#awsrun.argparse.AppendAttributeValuePair">AppendAttributeValuePair</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>