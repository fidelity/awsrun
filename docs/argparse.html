<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>awsrun.argparse API documentation</title>
<meta name="description" content="Provides additional actions and formatters for the builtin argparse module." />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css" rel="stylesheet">
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<!-- <link href="/awsrun/webfonts.css" rel="stylesheet"> -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,400;0,700;1,400;1,700&family=Roboto:ital,wght@0,300;0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
<style>
body {
font-size: 16px;
font-family: 'Roboto', sans-serif;
}
code {
font-family: 'Roboto Mono', monospace;
}
#content {
max-width: 100ch;
}
/* `Text` size and code in main body text */
section code {
font-size: 14px;
}
/* Line height for blocks of code in main text */
pre code {
font-size: 13px;
line-height: 1.35em;
}
/* "expand source code" text */
details {
font-size: 12px;
}
/* Code block in the expand source section */
.source pre code {
font-size: 12px;
line-height: 1.35em;
}
/* Navbar */
#sidebar code {
font-size: 13px;
}
#sidebar .toc {
font-size: 15px;
}
#sidebar h1 { font-size: 1.4em; }
#sidebar h3 { font-size: 1.10em; }
/* Used in method names sections etc .. */
code.name {
font-size: 14px;
}
.title code {
font-family: 'Roboto', sans-serif;
}
dt {
font-weight: bold;
}
h1 {
font-size: 2.0em;
}
</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>awsrun.argparse</code></h1>
</header>
<section id="section-intro">
<p>Provides additional actions and formatters for the builtin argparse module.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright 2019 FMR LLC &lt;opensource@fidelity.com&gt;
#
# SPDX-License-Identifier: MIT
#
&#34;&#34;&#34;Provides additional actions and formatters for the builtin argparse module.&#34;&#34;&#34;

import argparse
import builtins
import re


class RawAndDefaultsFormatter(
    argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter
):
    &#34;&#34;&#34;Mixin of ArgumentDefaultsHelpFormatter and RawDescriptionHelpFormatter.

    The argparse module does not allow for easy combinations of help formatters.
    This class combines the raw formatter along with the default args formatter,
    which is used by awsrun CLI.
    &#34;&#34;&#34;


class AppendWithoutDefault(argparse.Action):
    &#34;&#34;&#34;Argparse action to append to a list without the default.

    Out of the box, when using argparse to `append` options to a list, if a
    default has been provided in `add_argument`, then any options provided on
    the command line will be appended to that default list. For example, notice
    that `central` remains in the list:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=&#39;append&#39;, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;central&#39;, &#39;east&#39;, &#39;west&#39;])

    This class provides an argparse action that will only use the default value
    if no other values were provided on the command line. For example:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=AppendWithoutDefault, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;east&#39;, &#39;west&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;&#39;)
        Namespace(region=[&#39;central&#39;])
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.has_been_called = False
        super().__init__(*args, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        current = [] if not self.has_been_called else getattr(namespace, self.dest)
        current.append(values)
        setattr(namespace, self.dest, current)
        self.has_been_called = True


class AppendAttributeValuePair(argparse.Action):
    &#34;&#34;&#34;Argparse action to construct a dict of key/value pairs.

    Parses command line options into a dict of key/value pairs where multiple
    options and/or values are appended to the appropriate key/value pair. Option
    must be in either `name=val1,val2,etc` format or `name=type:val1,val2,etc`
    where `type` is one of `str`, `int`, `float`, or `bool`. The first format
    assumes a type of `str`. Examples will best illustrate use:

        &gt;&gt;&gt; import argparse
        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--flag&#39;, &#39;-f&#39;, action=AppendAttributeValuePair)
        &gt;&gt;&gt; def test(arg_string):
        ...   return parser.parse_args(arg_string.split()).flag
        ...
        &gt;&gt;&gt; test(&#39;-f env=prod&#39;)
        {&#39;env&#39;: [&#39;prod&#39;]}

    More than one value can be provided on the right-hand side of the `=`:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The option can be provided multiple times. If the left-hand side of the `=`
    is different, a new key is added to the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod -f status=active&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;], &#39;status&#39;: [&#39;active&#39;]}

    If the left-hand side is the same as a previous, the values are appended to
    the existing key in the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev -f env=qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The type of the comma separated values defaults to strings, but can be
    converted to ints, floats, or bools:

        &gt;&gt;&gt; test(&#39;-f level=1,2,3&#39;)
        {&#39;level&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]}

        &gt;&gt;&gt; test(&#39;-f level=int:1,2,3&#39;)
        {&#39;level&#39;: [1, 2, 3]}

        &gt;&gt;&gt; test(&#39;-f level=float:1,2,3&#39;)
        {&#39;level&#39;: [1.0, 2.0, 3.0]}

        &gt;&gt;&gt; test(&#39;-f level=bool:1,2,3&#39;)
        {&#39;level&#39;: [True, False, False]}
    &#34;&#34;&#34;

    def __call__(self, parser, namespace, values, option_string=None):
        match = re.match(r&#34;([^=]+)=(?:(str|int|float|bool):)?(.+)&#34;, values)  # type: ignore
        if not match:
            parser.error(f&#34;{option_string}: expected attr=val1,val2,etc&#34;)

        name, value_type, comma_sep_values = match.groups()
        cast = from_str_to(value_type)

        # Note: getattr below will always return a value because the argparse
        # Action sets the namespace attribute with a default value. That default
        # value may be None or a user-supplied dict. This means we can&#39;t use the
        # default parameter to getattr as the attribute will always exist.
        d = getattr(namespace, self.dest)

        # If it is None, then create a dict to store the parsed results.
        if d is None:
            d = {}

        # Normally I would use a defaultdict(list) when checking for a key
        # and setting a default value, but this cannot be used here as the
        # default provided by the user via parser.add_argument(default=...)
        # may be a regular dict, so we have to explicitly check for the name.
        if name not in d:
            d[name] = []

        try:
            d[name].extend(cast(v.strip()) for v in comma_sep_values.split(&#34;,&#34;))

        except ValueError:  # cast might throw an error
            parser.error(f&#34;{option_string}: invalid {value_type} in {match.group()}&#34;)

        setattr(namespace, self.dest, d)


def from_str_to(type_):
    &#34;&#34;&#34;Return a cast function to convert a string to a builtin type.

    The `type` parameter is the name of the type as a string. Returns the
    builtin Python cast function if `type` is &#34;str&#34;, &#34;int&#34;, or &#34;float&#34;. If
    `type` is &#34;bool&#34;, the returned cast function will return `True` for the
    values &#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, and &#34;1&#34; (case insensitive), otherwise it will
    return `False`. For any other `type` specified, the builtin `str`
    function is returned.

        &gt;&gt;&gt; f = from_str_to(&#34;str&#34;)
        &gt;&gt;&gt; f(&#34;hello&#34;)
        &#34;hello&#34;

        &gt;&gt;&gt; f = from_str_to(&#34;int&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10

        &gt;&gt;&gt; f = from_str_to(&#34;float&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10.0

        &gt;&gt;&gt; f = from_str_to(&#34;bool&#34;)
        &gt;&gt;&gt; [f(s) for s in [&#39;yes&#39;, &#39;no&#39;, &#39;true&#39;, &#39;false&#39;]]
        [True, False, True, False]
    &#34;&#34;&#34;
    if type_ in (&#34;str&#34;, &#34;int&#34;, &#34;float&#34;):
        return getattr(builtins, type_)
    if type_ == &#34;bool&#34;:
        return lambda s: s.lower() in (&#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, &#34;True&#34;, &#34;1&#34;)
    return str</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="awsrun.argparse.from_str_to"><code class="name flex">
<span>def <span class="ident">from_str_to</span></span>(<span>type_)</span>
</code></dt>
<dd>
<section class="desc"><p>Return a cast function to convert a string to a builtin type.</p>
<p>The <code>type</code> parameter is the name of the type as a string. Returns the
builtin Python cast function if <code>type</code> is "str", "int", or "float". If
<code>type</code> is "bool", the returned cast function will return <code>True</code> for the
values "y", "yes", "true", and "1" (case insensitive), otherwise it will
return <code>False</code>. For any other <code>type</code> specified, the builtin <code>str</code>
function is returned.</p>
<pre><code>&gt;&gt;&gt; f = from_str_to("str")
&gt;&gt;&gt; f("hello")
"hello"

&gt;&gt;&gt; f = from_str_to("int")
&gt;&gt;&gt; f("10")
10

&gt;&gt;&gt; f = from_str_to("float")
&gt;&gt;&gt; f("10")
10.0

&gt;&gt;&gt; f = from_str_to("bool")
&gt;&gt;&gt; [f(s) for s in ['yes', 'no', 'true', 'false']]
[True, False, True, False]
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_str_to(type_):
    &#34;&#34;&#34;Return a cast function to convert a string to a builtin type.

    The `type` parameter is the name of the type as a string. Returns the
    builtin Python cast function if `type` is &#34;str&#34;, &#34;int&#34;, or &#34;float&#34;. If
    `type` is &#34;bool&#34;, the returned cast function will return `True` for the
    values &#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, and &#34;1&#34; (case insensitive), otherwise it will
    return `False`. For any other `type` specified, the builtin `str`
    function is returned.

        &gt;&gt;&gt; f = from_str_to(&#34;str&#34;)
        &gt;&gt;&gt; f(&#34;hello&#34;)
        &#34;hello&#34;

        &gt;&gt;&gt; f = from_str_to(&#34;int&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10

        &gt;&gt;&gt; f = from_str_to(&#34;float&#34;)
        &gt;&gt;&gt; f(&#34;10&#34;)
        10.0

        &gt;&gt;&gt; f = from_str_to(&#34;bool&#34;)
        &gt;&gt;&gt; [f(s) for s in [&#39;yes&#39;, &#39;no&#39;, &#39;true&#39;, &#39;false&#39;]]
        [True, False, True, False]
    &#34;&#34;&#34;
    if type_ in (&#34;str&#34;, &#34;int&#34;, &#34;float&#34;):
        return getattr(builtins, type_)
    if type_ == &#34;bool&#34;:
        return lambda s: s.lower() in (&#34;y&#34;, &#34;yes&#34;, &#34;true&#34;, &#34;True&#34;, &#34;1&#34;)
    return str</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="awsrun.argparse.RawAndDefaultsFormatter"><code class="flex name class">
<span>class <span class="ident">RawAndDefaultsFormatter</span></span>
<span>(</span><span>prog, indent_increment=2, max_help_position=24, width=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Mixin of ArgumentDefaultsHelpFormatter and RawDescriptionHelpFormatter.</p>
<p>The argparse module does not allow for easy combinations of help formatters.
This class combines the raw formatter along with the default args formatter,
which is used by awsrun CLI.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RawAndDefaultsFormatter(
    argparse.ArgumentDefaultsHelpFormatter, argparse.RawDescriptionHelpFormatter
):
    &#34;&#34;&#34;Mixin of ArgumentDefaultsHelpFormatter and RawDescriptionHelpFormatter.

    The argparse module does not allow for easy combinations of help formatters.
    This class combines the raw formatter along with the default args formatter,
    which is used by awsrun CLI.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li>argparse.ArgumentDefaultsHelpFormatter</li></code>
<code><li>argparse.RawDescriptionHelpFormatter</li></code>
<code><li>argparse.HelpFormatter</li></code>
</ul>
</dd>
<dt id="awsrun.argparse.AppendWithoutDefault"><code class="flex name class">
<span>class <span class="ident">AppendWithoutDefault</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Argparse action to append to a list without the default.</p>
<p>Out of the box, when using argparse to <code>append</code> options to a list, if a
default has been provided in <code>add_argument</code>, then any options provided on
the command line will be appended to that default list. For example, notice
that <code>central</code> remains in the list:</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--region', action='append', default=['central'])
&gt;&gt;&gt; parser.parse_args('--region east --region west'.split())
Namespace(region=['central', 'east', 'west'])
</code></pre>
<p>This class provides an argparse action that will only use the default value
if no other values were provided on the command line. For example:</p>
<pre><code>&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--region', action=AppendWithoutDefault, default=['central'])
&gt;&gt;&gt; parser.parse_args('--region east --region west'.split())
Namespace(region=['east', 'west'])
&gt;&gt;&gt; parser.parse_args('')
Namespace(region=['central'])
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppendWithoutDefault(argparse.Action):
    &#34;&#34;&#34;Argparse action to append to a list without the default.

    Out of the box, when using argparse to `append` options to a list, if a
    default has been provided in `add_argument`, then any options provided on
    the command line will be appended to that default list. For example, notice
    that `central` remains in the list:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=&#39;append&#39;, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;central&#39;, &#39;east&#39;, &#39;west&#39;])

    This class provides an argparse action that will only use the default value
    if no other values were provided on the command line. For example:

        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--region&#39;, action=AppendWithoutDefault, default=[&#39;central&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;--region east --region west&#39;.split())
        Namespace(region=[&#39;east&#39;, &#39;west&#39;])
        &gt;&gt;&gt; parser.parse_args(&#39;&#39;)
        Namespace(region=[&#39;central&#39;])
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        self.has_been_called = False
        super().__init__(*args, **kwargs)

    def __call__(self, parser, namespace, values, option_string=None):
        current = [] if not self.has_been_called else getattr(namespace, self.dest)
        current.append(values)
        setattr(namespace, self.dest, current)
        self.has_been_called = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li>argparse.Action</li></code>
<code><li>argparse._AttributeHolder</li></code>
</ul>
</dd>
<dt id="awsrun.argparse.AppendAttributeValuePair"><code class="flex name class">
<span>class <span class="ident">AppendAttributeValuePair</span></span>
<span>(</span><span>option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)</span>
</code></dt>
<dd>
<section class="desc"><p>Argparse action to construct a dict of key/value pairs.</p>
<p>Parses command line options into a dict of key/value pairs where multiple
options and/or values are appended to the appropriate key/value pair. Option
must be in either <code>name=val1,val2,etc</code> format or <code>name=type:val1,val2,etc</code>
where <code>type</code> is one of <code>str</code>, <code>int</code>, <code>float</code>, or <code>bool</code>. The first format
assumes a type of <code>str</code>. Examples will best illustrate use:</p>
<pre><code>&gt;&gt;&gt; import argparse
&gt;&gt;&gt; parser = argparse.ArgumentParser()
&gt;&gt;&gt; parser.add_argument('--flag', '-f', action=AppendAttributeValuePair)
&gt;&gt;&gt; def test(arg_string):
...   return parser.parse_args(arg_string.split()).flag
...
&gt;&gt;&gt; test('-f env=prod')
{'env': ['prod']}
</code></pre>
<p>More than one value can be provided on the right-hand side of the <code>=</code>:</p>
<pre><code>&gt;&gt;&gt; test('-f env=dev,qa,prod')
{'env': ['dev', 'qa', 'prod']}
</code></pre>
<p>The option can be provided multiple times. If the left-hand side of the <code>=</code>
is different, a new key is added to the dict:</p>
<pre><code>&gt;&gt;&gt; test('-f env=dev,qa,prod -f status=active')
{'env': ['dev', 'qa', 'prod'], 'status': ['active']}
</code></pre>
<p>If the left-hand side is the same as a previous, the values are appended to
the existing key in the dict:</p>
<pre><code>&gt;&gt;&gt; test('-f env=dev -f env=qa,prod')
{'env': ['dev', 'qa', 'prod']}
</code></pre>
<p>The type of the comma separated values defaults to strings, but can be
converted to ints, floats, or bools:</p>
<pre><code>&gt;&gt;&gt; test('-f level=1,2,3')
{'level': ['1', '2', '3']}

&gt;&gt;&gt; test('-f level=int:1,2,3')
{'level': [1, 2, 3]}

&gt;&gt;&gt; test('-f level=float:1,2,3')
{'level': [1.0, 2.0, 3.0]}

&gt;&gt;&gt; test('-f level=bool:1,2,3')
{'level': [True, False, False]}
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AppendAttributeValuePair(argparse.Action):
    &#34;&#34;&#34;Argparse action to construct a dict of key/value pairs.

    Parses command line options into a dict of key/value pairs where multiple
    options and/or values are appended to the appropriate key/value pair. Option
    must be in either `name=val1,val2,etc` format or `name=type:val1,val2,etc`
    where `type` is one of `str`, `int`, `float`, or `bool`. The first format
    assumes a type of `str`. Examples will best illustrate use:

        &gt;&gt;&gt; import argparse
        &gt;&gt;&gt; parser = argparse.ArgumentParser()
        &gt;&gt;&gt; parser.add_argument(&#39;--flag&#39;, &#39;-f&#39;, action=AppendAttributeValuePair)
        &gt;&gt;&gt; def test(arg_string):
        ...   return parser.parse_args(arg_string.split()).flag
        ...
        &gt;&gt;&gt; test(&#39;-f env=prod&#39;)
        {&#39;env&#39;: [&#39;prod&#39;]}

    More than one value can be provided on the right-hand side of the `=`:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The option can be provided multiple times. If the left-hand side of the `=`
    is different, a new key is added to the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev,qa,prod -f status=active&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;], &#39;status&#39;: [&#39;active&#39;]}

    If the left-hand side is the same as a previous, the values are appended to
    the existing key in the dict:

        &gt;&gt;&gt; test(&#39;-f env=dev -f env=qa,prod&#39;)
        {&#39;env&#39;: [&#39;dev&#39;, &#39;qa&#39;, &#39;prod&#39;]}

    The type of the comma separated values defaults to strings, but can be
    converted to ints, floats, or bools:

        &gt;&gt;&gt; test(&#39;-f level=1,2,3&#39;)
        {&#39;level&#39;: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]}

        &gt;&gt;&gt; test(&#39;-f level=int:1,2,3&#39;)
        {&#39;level&#39;: [1, 2, 3]}

        &gt;&gt;&gt; test(&#39;-f level=float:1,2,3&#39;)
        {&#39;level&#39;: [1.0, 2.0, 3.0]}

        &gt;&gt;&gt; test(&#39;-f level=bool:1,2,3&#39;)
        {&#39;level&#39;: [True, False, False]}
    &#34;&#34;&#34;

    def __call__(self, parser, namespace, values, option_string=None):
        match = re.match(r&#34;([^=]+)=(?:(str|int|float|bool):)?(.+)&#34;, values)  # type: ignore
        if not match:
            parser.error(f&#34;{option_string}: expected attr=val1,val2,etc&#34;)

        name, value_type, comma_sep_values = match.groups()
        cast = from_str_to(value_type)

        # Note: getattr below will always return a value because the argparse
        # Action sets the namespace attribute with a default value. That default
        # value may be None or a user-supplied dict. This means we can&#39;t use the
        # default parameter to getattr as the attribute will always exist.
        d = getattr(namespace, self.dest)

        # If it is None, then create a dict to store the parsed results.
        if d is None:
            d = {}

        # Normally I would use a defaultdict(list) when checking for a key
        # and setting a default value, but this cannot be used here as the
        # default provided by the user via parser.add_argument(default=...)
        # may be a regular dict, so we have to explicitly check for the name.
        if name not in d:
            d[name] = []

        try:
            d[name].extend(cast(v.strip()) for v in comma_sep_values.split(&#34;,&#34;))

        except ValueError:  # cast might throw an error
            parser.error(f&#34;{option_string}: invalid {value_type} in {match.group()}&#34;)

        setattr(namespace, self.dest, d)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<code><li>argparse.Action</li></code>
<code><li>argparse._AttributeHolder</li></code>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="awsrun" href="index.html">awsrun</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="awsrun.argparse.from_str_to" href="#awsrun.argparse.from_str_to">from_str_to</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="awsrun.argparse.RawAndDefaultsFormatter" href="#awsrun.argparse.RawAndDefaultsFormatter">RawAndDefaultsFormatter</a></code></h4>
</li>
<li>
<h4><code><a title="awsrun.argparse.AppendWithoutDefault" href="#awsrun.argparse.AppendWithoutDefault">AppendWithoutDefault</a></code></h4>
</li>
<li>
<h4><code><a title="awsrun.argparse.AppendAttributeValuePair" href="#awsrun.argparse.AppendAttributeValuePair">AppendAttributeValuePair</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>